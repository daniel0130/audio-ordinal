<!DOCTYPE html>
<title>BOT 1t5</title>
<link rel="stylesheet" href="s.css">
<canvas id="cv"></canvas>
<!-- <iframe id="sequencer-iframe" src="EmbeddedSequencer/smallIndex.html"></iframe> -->

<style>@keyframes flash{0%{background-color:var(--primary-color)}50%{background-color:#0f0}100%{background-color:var(--primary-color)}}@keyframes flashingYellow{0%{background-color:#999902}50%{background-color:#ff0}100%{background-color:#999902}}.clear-button.flashing{animation:flashingYellow .5s infinite}.channel{display:flex}.ordinal-loaded{border:2px solid #f7931a}#play,#stop{flex:1;width:50px;height:50px}.clear-button,.mute-button,.solo-button{flex:1;min-width:18px;max-width:18px}.letter{z-index:1;font-size:16px;position:relative;left:-5px;top:-3px;color:#000}#play{animation:flash 2s infinite ease-in-out}#play.selected,#stop.selected~#play{animation:none}#stop.selected~#play,.mute-button.selected,.solo-button.selected{background-color:var(--accent-color)}#play.selected .letter,#stop.selected~#play .letter,.mute-button.selected .letter,.solo-button.selected .letter,.step-button.selected .letter{color:#fff}.clear-button,.mute-button,.solo-button{aspect-ratio:1/1}.clear-button{background-color:#999902}.mute-button{background-color:#800}.solo-button{background-color:#b16921}.solo-button.selected{background-color:#ff8000}.step-button{position:relative;min-width:0;aspect-ratio:1/1;background-color:#555;color:#fff;max-width:20px;max-height:20px}.color-FF0000 .step-button.selected{background-color:red}.color-00FF00 .step-button.selected{background-color:#0F0}.color-0000FF .step-button.selected{background-color:#00F}.color-FFFF00 .step-button.selected{background-color:#FF0}.color-00FFFF .step-button.selected{background-color:#0FF}.color-FF00FF .step-button.selected{background-color:#F0F}.color-808080 .step-button.selected{background-color:grey}.color-FFFFFF .step-button.selected{background-color:#FFF}.color-FFA500 .step-button.selected{background-color:orange}.color-800080 .step-button.selected{background-color:purple}.color-008080 .step-button.selected{background-color:teal}.color-000080 .step-button.selected{background-color:navy}.color-800000 .step-button.selected{background-color:maroon}.color-008000 .step-button.selected{background-color:green}.color-FFC0CB .step-button.selected{background-color:pink}.color-D2691E .step-button.selected{background-color:#D2691E}.step-button:nth-child(4n+1):not(:nth-child(16n+1)){background-color:#add8e6}.step-button:nth-child(16n+1){background-color:#ff0}.step-button.selected,.step-button.selected:nth-child(16n+1),.step-button.selected:nth-child(4n+1):not(:nth-child(16n+1)){background-color:var(--accent-color)}.step-button.selected{background-color:var(--accent-color)}.step-button.playing{box-shadow:0 0 10px #969696 inset}.step-button.playing.selected{box-shadow:0 0 10px #960101 inset}.step-button.dimmed{opacity:.5}.load-sample-button{flex:1;overflow:auto;text-overflow:ellipsis;font-size:.8em;height:20px;max-width:15%;min-width:10%;padding:1px;font-weight:700}.load-sample-button:hover::after{position:absolute;top:100%;left:0;background:var(--primary-color);color:var(--main-bg-color);z-index:1}.color-FF0000 .color-FF0000 .step-button.selected{background-color:red}.color-00FF00 .color-FF0000 .step-button.selected{background-color:#0F0}.color-0000FF .color-FF0000 .step-button.selected{background-color:#00F}.color-FFFF00 .color-FF0000 .step-button.selected{background-color:#FF0}.color-00FFFF .color-FF0000 .step-button.selected{background-color:#0FF}.color-FF00FF .color-FF0000 .step-button.selected{background-color:#F0F}.color-808080 .color-FF0000 .step-button.selected{background-color:grey}.color-FFFFFF .color-FF0000 .step-button.selected{background-color:#FFF}.color-FFA500 .color-FF0000 .step-button.selected{background-color:orange}.color-800080 .color-FF0000 .step-button.selected{background-color:purple}.color-008080 .color-FF0000 .step-button.selected{background-color:teal}.color-000080 .color-FF0000 .step-button.selected{background-color:navy}.color-800000 .color-FF0000 .step-button.selected{background-color:maroon}.color-008000 .color-FF0000 .step-button.selected{background-color:green}.color-FFC0CB .color-FF0000 .step-button.selected{background-color:pink}.color-D2691E .color-FF0000 .step-button.selected{background-color:#D2691E}.button,h1 .button{border:none;background-color:var(--primary-color);cursor:pointer;box-shadow:var(--box-shadow-style);color:var(--main-bg-color);font-size:1em}.control-button{width:var(--control-button-dimension);height:var(--control-button-dimension);display:flex;align-items:center;justify-content:center;font-weight:700;margin:0;position:relative}.play-button,.stop-button{position:relative;width:30px;height:30px;font-size:14px;padding:5px}#play.selected{background-color:#0f0}.stop-button{background-color:var(--accent-color)}.button-label.stop{color:red}div[idModalContent] div{display:flex;align-items:center;justify-content:flex-start;margin-bottom:10px;cursor:pointer}div[idModalContent] div button{margin-right:10px;background-color:#f0f0f0;border:none;border-radius:50%;width:30px;height:30px;display:flex;align-items:center;justify-content:center;cursor:pointer;transition:background-color .3s ease}div[idModalContent] div button:hover{background-color:#ddd}div[idModalContent] div a{text-decoration:none;display:flex;color:#000;transition:color .3s ease}div[idModalContent] div a:hover{color:#666}.dropdown:hover .dropbtn{background-color:#3e8e41}.action-button{border:none;color:#fff;text-align:center;text-decoration:none;display:inline-block;font-size:16px;cursor:pointer;border-radius:4px;transition:background-color .3s}.action-button:hover{background-color:#45a049}.tooltip{position:relative;display:inline-block;cursor:pointer}.tooltip .tooltiptext{visibility:hidden;max-width:150px;background-color:#333;color:#fff;text-align:center;border-radius:8px;position:absolute;z-index:1;bottom:calc(100% + 5px);left:50%;transform:translateX(-50%);opacity:.7;transition:opacity .3s;font-size:12px;pointer-events:none}.tooltip:hover .tooltiptext{visibility:visible;opacity:.7}.mode-switcher{display:flex;align-items:center;justify-content:center;margin-left:50px}.mode-switcher label{margin-right:10px}.mode-switcher input[type=checkbox]{appearance:none;width:40px;height:20px;background-color:#ccc;border-radius:10px;position:relative;cursor:pointer}.mode-switcher input[type=checkbox]:checked{background-color:#2196f3}.mode-switcher input[type=checkbox]::before{content:"";position:absolute;top:1px;left:1px;width:18px;height:18px;background-color:#fff;border-radius:50%;transition:transform .2s ease}.mode-switcher input[type=checkbox]:checked::before{transform:translateX(20px)}.custom-context-menu{position:absolute;background-color:#f9f9f9;border:1px solid #ccc;padding:5px;z-index:1000}body{background-color:var(--main-bg-color);color:var(--primary-color);font:normal normal normal 100%/1 var(--default-font)}#drum-machine{max-width:100%;margin:0 auto;padding:0;background-color:var(--secondary-bg-color);box-sizing:border-box}h1{text-align:center;display:flex;justify-content:space-between;align-items:center;position:relative}h3 .subtext{font-size:.8em;opacity:.7}h3:hover .subtext{font-size:1em;opacity:.5}.title{font-size:40px}.small-text,.smaller-text{font-size:20px}.larger-text{font-size:1.5em}.centered,.centered-text{display:block;text-align:center}.bright-orange{color:#f7931a}.drum-machine-container{width:95%;margin:0 auto;padding:20px}.steps-container{display:none}.drum-machine-container .steps-container{display:grid;grid-template-columns:repeat(64,minmax(10px,1fr));gap:0;overflow-x:auto}@media screen and (max-width:1280px){.drum-machine-container .steps-container{grid-template-columns:repeat(32,minmax(10px,1fr))}}@media screen and (max-width:1024px){.drum-machine-container .steps-container{grid-template-columns:repeat(16,minmax(10px,1fr))}}@media screen and (max-width:768px){.drum-machine-container .steps-container{grid-template-columns:repeat(16,minmax(10px,1fr))}}.controls-container{flex:1}.controls-container{margin:5px;border:1px solid #ccc;border-radius:5px;overflow:auto}*,::after,::before{box-sizing:border-box}.steps-container{display:none;grid-template-columns:repeat(64,minmax(10px,1fr));gap:0;overflow-x:auto}@media screen and (max-width:1280px){.steps-container{grid-template-columns:repeat(32,minmax(10px,1fr))}}@media screen and (max-width:1024px){.steps-container{grid-template-columns:repeat(16,minmax(10px,1fr))}}@media screen and (max-width:768px){.steps-container{grid-template-columns:repeat(16,minmax(10px,1fr))}}.channel-controls{margin-top:0}#sequence-lights{display:flex;flex-direction:row;justify-content:space-between;width:90%;margin-left:10%}.sequence-light{grid-column:span 1;height:15px;background-color:grey}.sequence-light.on{background-color:#adff2f}.quickplay-button-container{width:90%;margin:0 auto;display:flex;align-items:center;justify-content:center}.quick-play-button{width:30px;height:30px;padding:5px;margin:0 5px;display:flex;justify-content:center;align-items:center;background-color:#4CAF50;color:#fff;cursor:pointer}@media (max-width:600px){.quick-play-button{width:30px;height:30px;padding:3px}}.quick-play-button strong{display:block;font-weight:700}.quick-play-button.active{background-color:#32cd32}#next-sequence,#prev-sequence,button[for=mode-switcher]{font-size:12.5px;padding:5px 10px;font-weight:700}.loadSampleModalButton{position:fixed;left:0;top:0;width:100%;height:100%;background-color:rgba(0,0,0,.5);display:flex;justify-content:center;align-items:center;z-index:9999}.loadSampleModalButton-content{background-color:#fff;padding:20px;border-radius:10px;width:50%;max-height:500px;overflow-y:auto}.loadSampleModalButton-text{color:#000;margin-bottom:10px}.loadSampleModalButton-input{margin-bottom:10px;width:100%;box-sizing:border-box}.loadSampleModalButton button{margin-top:10px;padding:10px 15px;border:none;border-radius:5px;color:#fff;cursor:pointer}.loadSampleModalButton button:hover{background-color:#f6ff00;color:#000}.channel-naming-modal{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background-color:#fff;padding:20px;border-radius:10px;z-index:1000}.channel-name-input{width:100%;margin-bottom:10px}.loadSampleModalButton-link{padding:10px;margin-top:10px;color:#fff;background-color:#b0f;border:none;border-radius:5px;cursor:pointer}.loadSampleModalButton-link:hover{background-color:#b0f}.loadButton{background-color:#28a745}.cancelButton{background-color:#dc3545}.searchButton{background-color:#b0f}.tooltip{position:relative;display:inline-block}.tooltip .tooltiptext{visibility:hidden;width:120px;background-color:#000;color:#fff;text-align:center;border-radius:6px;padding:5px 0;position:absolute;z-index:1;bottom:125%;left:100%;margin-left:-60px;opacity:0;transition:opacity .3s}.tooltip .tooltiptext::after{content:"";position:absolute;top:100%;left:50%;margin-left:-5px;border-width:5px;border-style:solid;border-color:#000 transparent transparent transparent}.tooltip:hover .tooltiptext{visibility:visible;opacity:1}.load-popup{display:none;position:absolute;bottom:30px;right:0;border:1px solid #aaa;background-color:#f9f9f9;z-index:1000}.load-popup button{display:block;padding:10px;border:none;width:50%;text-align:left;cursor:pointer;background-color:#f9f9f9}.load-popup button:hover{background-color:#ddd}.modal{display:none;position:fixed;z-index:1;left:0;top:0;width:100%;height:100%;overflow:auto;background-color:#000;background-color:rgba(0,0,0,.4)}.modal-content{background-color:#fefefe;margin:15% auto;padding:20px;border:1px solid #888;width:80%}.close-button{color:#aaa;float:right;font-size:28px;font-weight:700}.close-button:focus,.close-button:hover{color:#000;text-decoration:none;cursor:pointer}#new-load-button,#save-button{margin-left:2px;right:0}#new-load-button{margin-left:2px;right:0;background-color:#fff;color:#000;animation:smooth-wave 4s linear infinite}@keyframes smooth-wave{0%{background-color:#fff;color:#000}25%{background-color:#fd6f6f;color:#000}50%{background-color:#fff;color:#000}75%{background-color:#ff6f6f;color:#000}100%{background-color:#fff;color:#000}}.copy-button{background-color:#2196F3}.copy-button:hover{background-color:#0b7dda}.paste-button{background-color:#FFC107}.paste-button:hover{background-color:#ffb300}:root{--scale-factor:1vw;--main-bg-color:#000;--secondary-bg-color:#333;--primary-color:#fff;--accent-color:#f00;--button-dimension:5vw;--control-button-dimension:18px;--box-shadow-style:0 0 1vw var(--main-bg-color)inset;--default-font:Arial,sans-serif}.channel{width:100%}</style><meta content="width=device-width,initial-scale=1"name=viewport><div class=drum-machine-container><div id=drum-machine><h1><span class=button-label>Play</span><div class="tooltip button button-round"><div class="button play-button"id=play></div><span class=tooltiptext>Start the sequence.</span></div><span class="button-label stop">Stop</span><div class="tooltip button button-round"><div class="button stop-button"id=stop></div><span class=tooltiptext>Stop the sequence.</span></div><div class="tooltip bpm-container">BPM: <input id=bpm-slider type=range max=180 min=60 step=1 title="Adjust the Beats Per Minute"value=105><div class=bpm-display id=bpm-display>105</div><span class=tooltiptext>Drag to adjust the BPM (Beats Per Minute) of the sequence.</span></div><span class=title>Audional Sequencer<br><span class=bright-orange>₿</span>itcoin<span class=bright-orange>₿</span>eats<span class="bright-orange small-text,">₿</span><span class=small-text>eta</span></span></h1><div class=utility-buttons><button class=tooltip id=save-button>Save <span class=tooltiptext>This button will save your sequence into JSON file for download so you can recall it later on.</span></button> <input id=save-file-input type=file style=display:none> <button class=tooltip id=new-load-button>Load <span class=tooltiptext>This button will load your audional composition JSON files, even while the sequencer is playing live.</span></button><div class=load-popup id=loadOptions><button id=loadJson>Load from Json file</button></div><input id=load-file-input type=file style=display:none accept=.json> <button class="tooltip action-button copy-button"id=copy-sequence-settings>Copy <span class=tooltiptext>Copy Sequence Steps</span></button> <button class="tooltip action-button paste-button"id=paste-button>Paste <span class=tooltiptext>Paste the sequence settings from clipboard.</span></button><label class=tooltip for=project-name>Project Name <span class=tooltiptext>Enter the project name</span></label><input id=project-name class=project-name placeholder="Enter project name"></div><div class=subtext-container><p class="centered-text subtext">Raw On-chain <span class=bright-orange>₿</span>itcoin Audionals: playing live, directly from the <span>₿</span>lockchain!</div><main id=app role=main><div class=channel-template style=display:none><div class=channel><button class="tooltip load-sample-button"title="Load New Audional">Load New Audional <span class=tooltiptext>Use this button to load a new audional sample into the current channel.</span></button> <button class="tooltip control-button open-audio-trimmer"style=background-color:#00f;font-weight:700><span class=letter>T</span> <span class=tooltiptext>Open Audio Trimmer for this channel.</span></button> <button class="tooltip control-button clear-button"><span class=letter>C</span> <span class=tooltiptext>Clear the current channel's sequence.</span><div class=clear-confirm style=display:none;position:absolute;background-color:rgba(0,0,0,.7);color:#fff;padding:5px;border-radius:3px;z-index:10>Click again to confirm clear</div></button> <button class="tooltip control-button mute-button"><span class=letter>M</span> <span class=tooltiptext>Mute or unmute the current channel.</span></button> <button class="tooltip control-button solo-button"><span class=letter>S</span> <span class=tooltiptext>Solo the current channel.</span></button><div class=steps-container></div></div></div></div></div><div class=quickplay-button-container><button class=tooltip id=prev-sequence>Previous Sequence <span class=tooltiptext>Go to the previous sequence</span></button> <span class=tooltip id=current-sequence-display>Sequence 0 <span class=tooltiptext>Currently displayed sequence</span> </span><button class=tooltip id=next-sequence>Next Sequence <span class=tooltiptext>Go to the next sequence</span></button><label class=tooltip for=continuous-play>Continuous Play <span class=tooltiptext>Toggle continuous play mode</span></label><input id=continuous-play type=checkbox checked class=tooltip></div><div class=modal id=audio-trimmer-modal hidden><div class=modal-content><span class=close-button>×</span><div id=audio-trimmer-container></div></div></div>
<script>


let cci2 = 18; // Initial CCI2 value
const initialCCI2 = 18; // Store the initial value of cci2 to reset later

// Simplified function to calculate cci2 based directly on channelIndex
function calculateCCI2(channelIndex) {
    if (channelIndex === undefined) {
        console.log("Warning: channelIndex is undefined. Unable to calculate CCI2.");
        return initialCCI2; // Return a safe value or handle the case appropriately
    }
    return channelIndex; // Directly use the channelIndex as the new value for cci2
}

// Existing resetToInitialState function
function resetToInitialState() {
    cci2 = 18; // Reset to initial cci2 value
    console.log(`Stop received. CCI2 reset to initial value ${initialCCI2}.`);
    // Trigger a visual update to reflect the reset cci2 value
    requestAnimationFrame(() => d(new Date().getTime())); // Force redraw with updated cci2
}


    const channelPlaybackListener = new BroadcastChannel('channel_playback');
    channelPlaybackListener.onmessage = (event) => {
        if (event.data.action === 'stop') {
            resetToInitialState(); // Reset everything to its initial state when stop is received
        } else {
            // Handle all other actions, including calculating cci2 based on channelIndex
            const { channelIndex } = event.data;
            cci2 = calculateCCI2(channelIndex);
            console.log(`Received channel playback: Channel ${channelIndex}. CCI2 updated to ${cci2}`);// based on seed ${seed}.`);
        }
    };

   

    // allInOneSequencer.js

const BASE_ORDINALS_URL="https://ordinals.com/content/";function isValidOrdinalsUrl(n){return new RegExp(`^${BASE_ORDINALS_URL}[a-f0-9]{64}i\\d+$`).test(n)}function formatId(n){return new RegExp("^[a-f0-9]{64}i\\d+$").test(n)?n:(console.error("Invalid ID format:",n),null)}function formatURL(n){if(n.startsWith(BASE_ORDINALS_URL))return n;const r=new RegExp(`^${BASE_ORDINALS_URL}${BASE_ORDINALS_URL}(.+)`),t=n.match(r);return t&&t[1]?BASE_ORDINALS_URL+t[1]:n.match(/^[a-f0-9]{64}i\d+$/)?BASE_ORDINALS_URL+n:n}function toFullUrl(n){return n?BASE_ORDINALS_URL+formatId(n):null}function extractIdFromUrl(n){return isValidOrdinalsUrl(n)?n.replace(BASE_ORDINALS_URL,""):(console.error("Invalid Ordinals URL:",n),null)}

let audioContext;
let isPaused = true;


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


class UnifiedSequencerSettings {
    constructor() {
        this.observers = [];
        this.settings = {
            masterSettings: {
                projectName: "New Audx Project",
                projectBPM: 120,
                currentSequence: 0,
                channelURLs: new Array(16).fill(""),
                trimSettings: Array.from({ length: 16 }, () => ({ start: 0.01, end: 100, length: 0 })),
                projectChannelNames: new Array(16).fill(""),
                projectSequences: this.initializeSequences(16, 16, 64)
            }
        };
        this.checkSettings = this.checkSettings.bind(this);
        this.clearMasterSettings = this.clearMasterSettings.bind(this);
    }

    exportSettings() {
        console.log("exportSettings entered");
        const exportedSettings = JSON.parse(JSON.stringify(this.settings.masterSettings));
        for (let sequenceKey in exportedSettings.projectSequences) {
            const sequence = exportedSettings.projectSequences[sequenceKey];
            for (let channelKey in sequence) {
                const channel = sequence[channelKey];
                const activeSteps = [];
                channel.steps.forEach((step, index) => {
                    if (step) activeSteps.push(index + 1);
                });
                channel.steps = activeSteps;
            }
        }
        const jsonString = JSON.stringify(exportedSettings);
        console.log("[exportSettings] Exported Settings:", jsonString);
        return jsonString;
    }

    isValidIndex(index) {
        // console.log("isValidIndex entered");
        return index >= 0 && index < 16;
    }

    loadSettings(settings) {
        console.log("[internalPresetDebug] loadSettings entered[loadSettings] URL storage after loading:", this.settings.masterSettings.channelURLs);
        try {
            console.log("[internalPresetDebug] Received JSON Settings:", settings);
            const parsedSettings = typeof settings === "string" ? JSON.parse(settings) : settings;
            console.log("[internalPresetDebug] Parsed Settings:", parsedSettings);
            this.settings.masterSettings.channelURLs = parsedSettings.channelURLs ? parsedSettings.channelURLs.map((url) => formatURL(url)) : [];
            this.settings.masterSettings.projectName = parsedSettings.projectName;
            this.settings.masterSettings.projectBPM = parsedSettings.projectBPM;
            this.settings.masterSettings.trimSettings = parsedSettings.trimSettings;
            this.settings.masterSettings.projectChannelNames = parsedSettings.projectChannelNames;
            console.log("[internalPresetDebug] Updated masterSettings with full URLs:", this.settings.masterSettings);
            if (parsedSettings.projectSequences) {
                for (let sequenceKey in parsedSettings.projectSequences) {
                    let sequence = parsedSettings.projectSequences[sequenceKey];
                    for (let channelKey in sequence) {
                        let channel = sequence[channelKey];
                        const steps = new Array(64).fill(false);
                        channel.steps.forEach(step => {
                            if (step >= 1 && step <= 64) steps[step - 1] = true;
                        });
                        channel.steps = steps;
                    }
                }
            }
            this.settings.masterSettings = parsedSettings;
            // console.log("[internalPresetDebug] Master settings after update:", this.settings.masterSettings);
            this.updateAllLoadSampleButtonTexts();
            this.notifyObservers();
        } catch (error) {
            console.error("[internalPresetDebug] Error loading settings:", error);
        }
    }

    addChannelURL(index, url) {
        if (index >= 0 && index < this.settings.masterSettings.channelURLs.length) {
            console.log(`[addChannelURL] Adding URL to channel ${index}: ${url}`);
            this.settings.masterSettings.channelURLs[index] = url;
            this.notifyObservers();
        } else {
            console.error(`[addChannelURL] Invalid channel index: ${index}`);
        }
    }

    getChannelURL(index) {
        if (index >= 0 && index < this.settings.masterSettings.channelURLs.length) {
            // console.log(`[getChannelURL] Retrieving URL from channel ${index}: ${this.settings.masterSettings.channelURLs[index]}`);
            return this.settings.masterSettings.channelURLs[index];
        } else {
            console.error(`[getChannelURL] Invalid channel index: ${index}`);
            return null;
        }
    }

    getProjectUrlforChannel(index) {
        // console.log("getProjectUrlforChannel entered");
        return this.settings.masterSettings.channelURLs[index];
    }

    setChannelURLs(urls) {
        console.log("setProjectURLs entered");
        this.settings.masterSettings.channelURLs = urls;
        console.log("[setChannelURLs] Channel URLs set:", urls);
        this.updateAllLoadSampleButtonTexts();
    }

    setProjectName(name) {
        console.log("setProjectName entered");
        this.settings.masterSettings.projectName = name;
        console.log(`[setProjectName] Project name set to: ${name}`);
    }

    clearMasterSettings() {
        console.log("[clearMasterSettings] Current masterSettings before clearing:", this.settings.masterSettings);
        this.settings.masterSettings = {
            projectName: "",
            projectBPM: 120,
            currentSequence: 0,
            channelURLs: new Array(16).fill(""),
            trimSettings: Array.from({ length: 16 }, () => ({ start: 0.01, end: 100, length: 0 })),
            projectChannelNames: new Array(16).fill(""),
            projectSequences: this.initializeSequences(16, 16, 64)
        };
        console.log("[clearMasterSettings] Master settings cleared.");
    }

    initializeSequences(numSequences, numChannels, numSteps) {
        console.log("initializeSequences entered", numSequences, numChannels, numSteps);
        let sequences = {};
        for (let i = 0; i < numSequences; i++) {
            sequences[`Sequence${i}`] = this.initializeChannels(numChannels, numSteps);
        }
        return sequences;
    }

    initializeChannels(numChannels, numSteps) {
        console.log("initializeChannels entered", numChannels, numSteps);
        let channels = {};
        for (let i = 0; i < numChannels; i++) {
            channels[`ch${i}`] = {
                steps: new Array(numSteps).fill(false),
                mute: false,
                url: ""
            };
        }
        return channels;
    }

    initializeTrimSettings(numChannels) {
        console.log("initializeTrimSettings entered");
        if (channelIndex < 1) console.log("initializeTrimSettings", numChannels);
        return Array.from({ length: numChannels }, () => ({ start: 0, end: 100, length: 0 }));
    }

    updateTrimSettingsUI(settings) {
        console.log("Trim settings UI entered and updated:", settings);
        settings.forEach((setting, index) => {
            const startSlider = document.getElementById(`start-slider-${index}`);
            const endSlider = document.getElementById(`end-slider-${index}`);
            if (startSlider && endSlider) {
                startSlider.value = setting.start;
                endSlider.value = setting.end;
            }
        });
    }

    addObserver(observer) {
        console.log("addObserver", observer);
        this.observers.push(observer);
    }

    notifyObservers() {
        // console.log("notifyObservers");
        this.observers.forEach(observer => observer(this.settings));
    }

    setTrimSettings(index, start, end) {
        console.log("setTrimSettings entered");
        if (index < 1) console.log("setTrimSettings", index, start, end);
        if (this.isValidIndex(index)) {
            const trimSetting = this.settings.masterSettings.trimSettings[index];
            if (trimSetting) {
                Object.assign(trimSetting, { start: start, end: end });
            } else {
                console.error(`Trim settings not found for channel index: ${index}`);
            }
        } else {
            console.error(`Invalid channel index: ${index}`);
        }
    }

    getTrimSettings(index) {
        console.log("getTrimSettings entered");
        if (index < 1) console.log("getTrimSettings", index);
        return this.settings.masterSettings.trimSettings[index] || { start: 0.01, end: 100 };
    }
    
    updateTrimSettingsUI(settings) {
        console.log("updateTrimSettingsUI entered", settings);
        console.log("Trim settings UI updated:", settings);
        settings.forEach((setting, index) => {
            const startSlider = document.getElementById(`start-slider-${index}`);
            const endSlider = document.getElementById(`end-slider-${index}`);
            if (startSlider && endSlider) {
                startSlider.value = setting.start;
                endSlider.value = setting.end;
            }
        });
    }
    
    setProjectName(index, name) {
        console.log("setProjectName entered");
        if (index < 1) console.log("setProjectName", index, name);
        this.settings.masterSettings.projectName[index] = name;
        this.notifyObservers();
    }
    
    setCurrentSequence(sequence) {
        console.log("[SeqDebug] setCurrentSequence entered with: ", sequence);
        this.settings.masterSettings.currentSequence = sequence;
        console.log(`[SeqDebug] [setCurrentSequence] currentSequence set to: ${sequence}`);
        console.log(`[SeqDebug] [setCurrentSequence] Object currentSequence set to: ${this.settings.masterSettings.currentSequence}`);
    }
    getCurrentSequence() {
        // console.log("getCurrentSequence entered");
        return this.settings.masterSettings.currentSequence;
    }
    
    getSequenceSettings(sequenceIndex) {
        // console.log("getSequenceSettings entered");
        const sequenceKey = `Sequence${sequenceIndex}`;
        return this.settings.masterSettings.projectSequences[sequenceKey];
    }
    
    setSequenceSettings(sequenceIndex, settings) {
        console.log("setSequenceSettings entered");
        const sequenceKey = `Sequence${sequenceIndex}`;
        this.settings.masterSettings.projectSequences[sequenceKey] = settings;
    }
    
    getSettings(key) {
        // console.log("getSettings entered", key);
        if (key === "masterSettings") {
            // console.log("[getSettings] Retrieved all masterSettings:", this.settings.masterSettings);
            return this.settings.masterSettings;
        }
        if (key) {
            const value = this.settings.masterSettings[key];
            // console.log(`[getSettings] Retrieved setting for key '${key}':`, value);
            return value;
        }
        // console.log("[getSettings] Retrieved all settings:", this.settings);
        return this.settings;
    }
    
    checkSettings() {
        // console.log("checkSettings entered");
        // console.log("[checkSettings] Current masterSettings:", this.settings.masterSettings);
        return this.settings.masterSettings;
    }
    updateProjectSequencesUI() {
        console.log("updateProjectSequencesUI entered");
        channelIndex < 1 && console.log("updateProjectSequencesUI");
        this.getSettings("projectSequences").forEach((sequence, index) => {
            updateSequenceUI(index, sequence);
        });
    }
    
    updateStepState(sequenceIndex, channelIndex, stepIndex, state) {
        // console.log("updateStepState entered");
        if (channelIndex < 1) 
        console.log(`[updateStepState] Called with Sequence: ${sequenceIndex}, Channel: ${channelIndex}, Step: ${stepIndex}, State: ${state}`);
        const sequence = this.settings.masterSettings.projectSequences[`Sequence${sequenceIndex}`];
        const channel = sequence && sequence[`ch${channelIndex}`];
        if (channel && stepIndex < channel.steps.length) {
            channel.steps[stepIndex] = state;
        } else {
            console.error("Invalid sequence, channel, or step index in updateStepState");
        }
    }
    
    getStepState(sequenceIndex, channelIndex, stepIndex) {
        // console.log("getStepState entered");
        if (channelIndex < 1) console.log(`[getStepState] Called with Sequence: ${sequenceIndex}, Channel: ${channelIndex}, Step: ${stepIndex}`);
        const sequence = this.settings.masterSettings.projectSequences[`Sequence${sequenceIndex}`];
        const channel = sequence && sequence[`ch${channelIndex}`];
        return channel && stepIndex < channel.steps.length ? channel.steps[stepIndex] : (console.error("Invalid sequence, channel, or step index in getStepState"), null);
    }
    
    updateSetting(key, value, channelIndex = null) {
        console.log("updateSetting entered");
        if (channelIndex < 1) console.log(`[updateSetting] Called with key: ${key}, value: ${value}, channelIndex: ${channelIndex}`);
        if (channelIndex !== null && Array.isArray(this.settings.masterSettings[key])) {
            this.settings.masterSettings[key][channelIndex] = value;
        } else if (key in this.settings.masterSettings) {
            this.settings.masterSettings[key] = value;
        } else {
            console.error(`Setting ${key} does not exist in masterSettings`);
        }
    }
    
    updateSampleDuration(duration, channelIndex) {
        console.log("updateSampleDuration entered");
        if (channelIndex < 1) console.log(`[updateSampleDuration] Called with duration: ${duration}, channelIndex: ${channelIndex}`);
        if (this.isValidIndex(channelIndex)) {
            this.settings.masterSettings.trimSettings[channelIndex].length = duration;
        } else {
            console.error(`Invalid channel index: ${channelIndex}`);
        }
    }
    
    getBPM() {
        return this.settings.masterSettings.projectBPM;
    }
    
    setBPM(bpm) {
        this.settings.masterSettings.projectBPM = bpm;
    }

    setProjectChannelName(channelIndex, name) {
        console.log("setProjectChannelName entered");
        if (this.isValidIndex(channelIndex)) {
            if (this.settings.masterSettings.projectChannelNames[channelIndex] !== name) {
                this.settings.masterSettings.projectChannelNames[channelIndex] = name;
                console.log(`[setChannelName] Channel ${channelIndex} name set to: ${name}`);
                this.notifyObservers();
            }
        } else {
            console.error(`[setChannelName] Invalid channel index: ${channelIndex}`);
        }
    }
    
    setProjectSequences(sequences) {
        console.log("setProjectSequences entered");
        this.settings.masterSettings.projectSequences = sequences;
    //     console.log("[setProjectSequences] Project sequences set:", sequences);
    //     console.log("[setProjectSequences] currentSequence set to:", this.settings.masterSettings.currentSequence);
    }

    ensureArrayLength(array, desiredLength, defaultValue) {
        // console.log("ensureArrayLength entered");
        for (; array.length < desiredLength;) {
            array.push(defaultValue);
        }
    }
    
    updateAllLoadSampleButtonTexts() {
        // console.log("updateAllLoadSampleButtonTexts entered");
        document.querySelectorAll(".channel").forEach((element, index) => {
            const loadSampleButton = element.querySelector(".load-sample-button");
            if (loadSampleButton) {
                this.updateLoadSampleButtonText(index, loadSampleButton);
            }
        });
    }
    
    updateLoadSampleButtonText(channelIndex, buttonElement) {
        console.log("updateLoadSampleButtonText entered");
        let buttonText = "Load New Audional";
        const channelName = this.settings.masterSettings.projectChannelNames[channelIndex];
        const channelURL = this.settings.masterSettings.channelURLs[channelIndex];
        if (channelName) {
            buttonText = channelName;
        } else if (channelURL) {
            const parts = channelURL.split("/");
            buttonText = parts[parts.length - 1];
        }
        buttonElement.textContent = buttonText;
    }
    updateProjectNameUI(projectName) {
        console.log("Project name UI entered and updated:", projectName);
        const projectNameElement = document.getElementById("project-name");
        if (projectNameElement) {
            projectNameElement.value = projectName || "AUDX Project";
            console.log("Project name UI updated:", projectName);
        }
    }
    
    updateBPMUI(bpm) {
        const bpmSlider = document.getElementById("bpm-slider");
        const bpmDisplay = document.getElementById("bpm-display");
        if (bpmSlider && bpmDisplay) {
            bpmSlider.value = bpm;
            bpmDisplay.textContent = bpm;
            console.log("BPM UI updated:", bpm);
        }
    }
    updateProjectURLsUI(urls) {
        console.log("Project URLs UI entered and updated:", urls);
        urls.forEach((url, index) => {
            const urlInputElement = document.getElementById(`url-input-${index}`);
            if (urlInputElement) {
                urlInputElement.value = url;
            }
        });
    }
    
    updateProjectChannelNamesUI(names) {
        console.log("Project URL names UI entered and updated:", names);
        names.forEach((name, index) => {
            const urlNameElement = document.getElementById(`url-name-${index}`);
            if (urlNameElement) {
                urlNameElement.textContent = name;
            }
        });
    }
    ensureArrayLength(array, desiredLength) {
        for (; array.length < desiredLength;) {
            array.push(this.getDefaultArrayElement());
        }
    }
    
    getDefaultArrayElement() {
        return {
            start: 0.01,
            end: 100,
            length: 0
        };
    }
}

window.unifiedSequencerSettings=new UnifiedSequencerSettings;


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

let currentTrimmerInstance=null,currentTrimmerChannelIndex=null;function updateAudioTrimmerWithBufferHelper(e,r){if(console.log("updateAudioTrimmerWithBufferHelper entered"),audioBuffers.has(e)){updateAudioTrimmerWithBuffer(audioBuffers.get(e),r)}else console.error(`Audio buffer not found for URL: ${e}`)}function updateAudioTrimmerWithBuffer(e){console.log("updateAudioTrimmerWithBuffer entered"),currentTrimmerInstance&&(currentTrimmerInstance.setAudioBuffer(e),currentTrimmerInstance.drawWaveform(),console.log(" updateDimmedAreas method called from updateaudioTrimmerWithBuffer"),currentTrimmerInstance.updateSliderValues(),currentTrimmerInstance.updateDimmedAreas())}function playTrimmedAudioForChannel(e){console.log("playTrimmedAudioForChannel entered"),currentTrimmerInstance&&currentTrimmerChannelIndex===e?currentTrimmerInstance.playTrimmedAudio():console.error("No active trimmer instance for the channel or channel index mismatch")}function stopAudioForChannel(e){currentTrimmerInstance&&currentTrimmerInstance.channelIndex===e?currentTrimmerInstance.stopAudio():console.error("No active trimmer instance for the channel or channel index mismatch")}document.addEventListener("DOMContentLoaded",(function(){}));
class AudioTrimmer{constructor(t){console.log("[Class Functions] constructor",{channelIndex:t}),this.channelIndex=t,this.audioContext=new(window.AudioContext||window.webkitAudioContext),this.audioBuffer=null,this.isPlaying=!1,this.isLooping=!1,this.initializeSliderTrack(t);const e=getTrimSettings(this.channelIndex);console.log("getSettings read into trimSettings in AudioTrimmer class constructor",e),this.startSliderValue=e.startSliderValue,this.endSliderValue=e.endSliderValue,console.log("startSliderValue and endSliderValue in AudioTrimmer class constructor",this.startSliderValue,this.endSliderValue),this.displayTimeout=null}initializeSliderTrack(){this.sliderTrack=document.querySelector(".slider-track"),this.sliderTrack||console.error("Slider track not found")}updateTrimmedSampleDuration(){const t=this.startSliderValue,e=this.endSliderValue;this.trimmedSampleDuration=Math.max(0,e-t),this.debounceDisplayValues()}getStartSliderValue(){return this.startSliderValue}getEndSliderValue(){return this.endSliderValue}sliderValueToTimecode(t,e){return t/100*e}debounceDisplayValues(){this.displayTimeout&&clearTimeout(this.displayTimeout),this.displayTimeout=setTimeout((()=>this.displayValues()),300)}displayValues(){console.log("Start Slider Value:",this.startSliderValue),console.log("End Slider Value:",this.endSliderValue),console.log("Trimmed Sample Duration:",this.trimmedSampleDuration)}setAudioBuffer(t){console.log("[Class Functions] setAudioBuffer",{audioBuffer:t}),this.audioBuffer=t,this.drawWaveform(),console.log(" updateDimmedAreas method called from setAudioBuffer"),this.updateDimmedAreas(),this.updateSliderValues()}drawWaveform(){if(console.log("[Class Functions] drawWaveform"),!this.audioBuffer)return void console.log("[Class Functions] drawWaveform - No audio buffer");const t=this.waveformCanvas.width,e=this.waveformCanvas.height,i=this.audioBuffer.getChannelData(0),s=Math.ceil(i.length/t),o=e/2;this.ctx.clearRect(0,0,t,e),this.ctx.beginPath();for(let e=0;e<t;e++){const{min:t,max:a}=this.getMinMax(i,e*s,s);this.ctx.moveTo(e,o*(1+t)),this.ctx.lineTo(e,o*(1+a))}this.ctx.stroke()}async initialize(){console.log("[Class Functions] initialize");let t=!0;["ordinalIdInput","loadSampleButton","waveformCanvas","playbackCanvas","trimmerPlayButton","trimmerStopButton","loopButton","startDimmed","endDimmed","startSlider","endSlider"].forEach((e=>{this[e]=document.getElementById(e),this[e]||(console.error(`[Class Functions] initialize - Element not found: ${e}`),t=!1)})),t?(this.ctx=this.waveformCanvas.getContext("2d"),this.addEventListeners(),console.log(" updateDimmedAreas method called from initialize"),this.updateDimmedAreas(),this.updateSliderValues()):(console.log("[Class Functions] initialize - Waiting for elements to be available"),setTimeout((()=>this.initialize()),500));const e=getTrimSettings(this.channelIndex);this.startSlider.value=e.startSliderValue,this.endSlider.value=e.endSliderValue,this.isLooping=e.isLooping,this.updateLoopButtonState(),this.updateDimmedAreas(),this.updateSliderValues(),this.playbackCtx=this.playbackCanvas.getContext("2d"),this.playbackCtx.fillStyle="red"}updateSliderValues(){const t=this.startSliderValue/100*this.sliderTrack.offsetWidth,e=this.endSliderValue/100*this.sliderTrack.offsetWidth;this.startSlider.style.left=`${t}px`,this.endSlider.style.left=`${e}px`,this.updateDimmedAreas(),console.log("updateDimmedAreas method called from updateSliderValues"),this.updateTrimmedSampleDuration(),this.debounceDisplayValues()}updateDimmedAreas(){console.log("[Class Functions] updateDimmedAreas function entered into");const t=this.startSliderValue,e=this.endSliderValue,i=`${t}%`,s=100-e+"%";this.startDimmed.style.width=i,this.startDimmed.style.left="0",this.endDimmed.style.width=s,this.endDimmed.style.left=`${e}%`}addEventListeners(){console.log("[Class Functions] addEventListeners"),this.boundPlayTrimmedAudio=this.playTrimmedAudio.bind(this),this.boundStopAudio=this.stopAudio.bind(this),this.trimmerPlayButton.removeEventListener("click",this.boundPlayTrimmedAudio),this.trimmerStopButton.removeEventListener("click",this.boundStopAudio),this.trimmerPlayButton.addEventListener("click",this.boundPlayTrimmedAudio),this.trimmerStopButton.addEventListener("click",this.boundStopAudio),this.loopButton.addEventListener("click",this.toggleLoop.bind(this));const t=(t,e)=>{const i=e?this.startSlider:this.endSlider;if(console.log("[Slider Mouse Down] Slider: "+(e?"Start":"End")),!i)return void console.error("Slider element is undefined");const s=t.clientX-i.getBoundingClientRect().left;document.onmousemove=t=>{if(!this.sliderTrack)return void console.error("Slider track is undefined");let o=t.clientX-s-this.sliderTrack.getBoundingClientRect().left;if(o=Math.max(0,Math.min(o,this.sliderTrack.offsetWidth-i.offsetWidth)),e){const t=this.endSlider.getBoundingClientRect().left-this.sliderTrack.getBoundingClientRect().left;o=Math.min(o,t)}else{const t=this.startSlider.getBoundingClientRect().right-this.sliderTrack.getBoundingClientRect().left;o=Math.max(o,t)}i.style.left=`${o}px`;const a=o/this.sliderTrack.offsetWidth*100;e?this.startSliderValue=a:this.endSliderValue=a;let n=unifiedSequencerSettings.settings.masterSettings.trimSettings;n[this.channelIndex]={...n[this.channelIndex],startSliderValue:this.startSliderValue,endSliderValue:this.endSliderValue},updateTrimSettingsUI(n),this.updateSliderValues()},document.onmouseup=()=>{document.onmousemove=document.onmouseup=null}};this.startSlider.addEventListener("mousedown",(e=>t(e,!0))),this.endSlider.addEventListener("mousedown",(e=>t(e,!1)))}async loadSample(){if(console.log("[Class Functions] loadSample"),this.ordinalIdInput.value)try{this.audioBuffer=await fetchAudio(`https://ordinals.com/content/${this.ordinalIdInput.value}`),this.trimSettings=getTrimSettings(this.channelIndex),this.drawWaveform(),console.log(" updateDimmedAreas method called from loadSample"),this.updateSliderValues(),this.updateDimmedAreas()}catch(t){console.error("Error loading audio:",t)}}getMinMax(t,e,i){let s=1,o=-1;for(let a=0;a<i;a++){const i=t[e+a];i<s&&(s=i),i>o&&(o=i)}return{min:s,max:o}}getIsLooping(){return this.isLooping}setIsLooping(t){this.isLooping=t,this.updateLoopButtonState()}updateLoopButtonState(){console.log(`[updateLoopButtonState] isLooping: ${this.isLooping}`),this.loopButton&&(this.isLooping?(this.loopButton.classList.add("on"),this.loopButton.classList.remove("off")):(this.loopButton.classList.add("off"),this.loopButton.classList.remove("on")))}playTrimmedAudio(){if(console.log("[playTrimmedAudio] [Class Functions] playTrimmedAudio"),this.isPlaying)return void console.log("[playTrimmedAudio] Audio is already playing, not starting new playback");if(!this.audioBuffer)return void console.error("[playTrimmedAudio] No audio buffer loaded");this.isPlaying=!0,console.log("[playTrimmedAudio] isPlaying set to true, starting new playback");const t=this.sliderValueToTimecode(this.startSliderValue,this.audioBuffer.duration);this.startTime=this.audioContext.currentTime-t;const e=this.sliderValueToTimecode(this.startSliderValue,this.audioBuffer.duration),i=this.sliderValueToTimecode(this.endSliderValue,this.audioBuffer.duration);this.sourceNode&&this.sourceNode.disconnect(),this.sourceNode=this.audioContext.createBufferSource(),this.sourceNode.buffer=this.audioBuffer,this.sourceNode.connect(this.audioContext.destination),this.sourceNode.loop=this.isLooping,this.isLooping&&(this.sourceNode.loopStart=e,this.sourceNode.loopEnd=i),this.sourceNode.start(0,e,i-e),console.log("[playTrimmedAudio] Playback started"),this.animatePlayback(),this.sourceNode.onended=()=>{this.isPlaying=!1,this.isLooping?this.playTrimmedAudio():(console.log("[playTrimmedAudio] Playback ended, isPlaying set to false"),this.animationFrameRequest&&cancelAnimationFrame(this.animationFrameRequest))}}stopAudio(){console.log("[Class Functions] stopAudio"),this.setIsLooping(!1),this.isPlaying&&this.sourceNode&&(this.sourceNode.stop(),this.sourceNode.disconnect(),this.sourceNode=null,this.isPlaying=!1),this.animationFrameRequest&&cancelAnimationFrame(this.animationFrameRequest)}toggleLoop(){console.log("[Class Functions] toggleLoop"),this.isLooping=!this.isLooping,this.updateLoopButtonState(),this.isPlaying&&this.playTrimmedAudio()}getCurrentPlaybackPosition(){if(!this.isPlaying)return 0;const t=this.sliderValueToTimecode(this.startSliderValue,this.audioBuffer.duration);return(this.audioContext.currentTime-this.startTime)%this.audioBuffer.duration+t}updatePlaybackCanvas(){const t=this.audioContext.currentTime-this.startTime,e=this.sliderValueToTimecode(this.startSliderValue,this.audioBuffer.duration),i=this.sliderValueToTimecode(this.endSliderValue,this.audioBuffer.duration)-e,s=(t-e)%i;if(s<0||s>i)return;const o=this.playbackCanvas.width,a=this.playbackCanvas.height,n=this.startSliderValue/100*o,l=n+s/i*(this.endSliderValue/100*o-n);this.playbackCtx.clearRect(0,0,o,a),this.playbackCtx.beginPath(),this.playbackCtx.moveTo(l,0),this.playbackCtx.lineTo(l,a),this.playbackCtx.strokeStyle="#FF0000",this.playbackCtx.lineWidth=2,this.playbackCtx.stroke()}animatePlayback(){this.isPlaying?(console.log("[animatePlayback] Animation frame requested."),this.updatePlaybackCanvas(),this.animationFrameRequest=requestAnimationFrame((()=>this.animatePlayback()))):console.log("[animatePlayback] Animation stopped. 'isPlaying' is false.")}}
function getChannelURL(index) {
    // console.log(`[getChannelURL] URL for channel ${index}:`, this.getChannelURL(index));

    // Ensure that we are accessing the 'channelURLs' array correctly
    if (index >= 0 && index < window.unifiedSequencerSettings.settings.masterSettings.channelURLs.length) {
        // console.log(`Retrieving URL for channel index: ${index}`);
        return window.unifiedSequencerSettings.settings.masterSettings.channelURLs[index];
    } else {
        console.error(`Invalid channel index: ${index}`);
        return null; // Or handle the error as needed
    }
}

function updateTrimSettingsUI(e){console.log("debugGlobalObjectToUI - entered"),console.log("{debugGlobalObjectToUI} updateTrimSettingsUI: updating with trimSettings",e),console.log("Trim settings UI updated:",e),e.forEach(((e,t)=>{const n=document.getElementById(`start-slider-${t}`),o=document.getElementById(`end-slider-${t}`);n&&o&&(n.value=e.startSliderValue,o.value=e.endSliderValue)}))}function updateProjectChannelNamesUI(e){console.log("debugGlobalObjectToUI - entered"),console.log("{debugGlobalObjectToUI} updateProjectChannelNamesUI: updating with URL names",e),console.log("Project URL names UI updated:",e),e.forEach(((e,t)=>{const n=document.getElementById(`url-name-${t}`);n&&(n.textContent=e)}))}function updateBPMUI(e){console.log("debugGlobalObjectToUI - entered");const t=document.getElementById("bpm-slider"),n=document.getElementById("bpm-display");t&&n&&(t.value=e,n.textContent=e)}function updateProjectNameUI(e){console.log("debugGlobalObjectToUI - entered");const t=document.getElementById("project-name");t&&(t.value=e)}function updateSpecificStepUI(e,t,n){console.log("debugGlobalObjectToUI - entered");const o=`Sequence${e}-ch${t}-step-${n}`;console.log(`Looking for step button with ID: ${o}`);const c=document.getElementById(o);if(c){let s=window.unifiedSequencerSettings.getStepState(e,t,n);console.log(`[updateSpecificStepUI] Step button found: Sequence ${e}, Channel ${t}, Step ${n}, Current State: ${s}`),s?(c.classList.add("selected"),console.log(`[updateSpecificStepUI] Added 'selected' class to step button with ID: ${o}`)):(c.classList.remove("selected"),console.log(`[updateSpecificStepUI] Removed 'selected' class from step button with ID: ${o}`))}else console.error(`Step button not found for the given IDs: ${o}`)}function getProjectSequences(){console.log("debugGlobalObjectToUI - entered");window.unifiedSequencerSettings;return window.unifiedSequencerSettings.getSettings("projectSequences")}function setGlobalProjectURLs(e){console.log("debugGlobalObjectToUI - entered"),window.unifiedSequencerSettings.setProjectURLs(e),console.log("[setGlobalProjectURLs] Project URLs updated:",e)}

// Updated to include totalSampleDuration in the setting logic
function setTrimSettings(channelIndex, startValue, endValue, totalDuration) {
    console.log("setTrimSettings entered", channelIndex, startValue, endValue, totalDuration);
    if (this.isValidIndex(channelIndex)) {
        const trimSettings = this.settings.masterSettings.trimSettings[channelIndex];
        if (trimSettings) {
            Object.assign(trimSettings, {
                startSliderValue: startValue,
                endSliderValue: endValue,
                totalSampleDuration: totalDuration
            });
        } else {
            console.error(`Trim settings not found for channel index: ${channelIndex}`);
        }
    } else {
        console.error(`Invalid channel index: ${channelIndex}`);
    }
}

function updateProjectSequencesUI(e){console.log("debugGlobalObjectToUI - entered"),console.log("{debugGlobalObjectToUI} [updateProjectSequencesUI] updateProjectSequencesUI: updating with sequences",e),console.log(`[updateProjectSequencesUI] Total sequences to process: ${Object.keys(e).length}`),Object.keys(e).forEach((t=>{const n=e[t];console.log(`[updateProjectSequencesUI] Processing sequence: ${t}`),Object.keys(n).forEach((e=>{const o=n[e].steps;Array.isArray(o)?o.forEach(((n,o)=>{const c=`${t}-${e}-step-${o}`,s=document.getElementById(c);s&&(!0===n?s.classList.contains("selected")||s.classList.add("selected"):s.classList.contains("selected")&&(console.log(`[updateProjectSequencesUI] Removing 'selected' class from stepControl: ${c}`),s.classList.remove("selected")))})):console.log(`[updateProjectSequencesUI] Steps data for channel ${e} in sequence ${t} is not an array`)}))}))}function getTrimSettings(e){return console.log("debugGlobalObjectToUI - entered"),window.unifiedSequencerSettings.getTrimSettings(e)}document.addEventListener("DOMContentLoaded",(()=>{for(let e=0;e<16;e++)for(let t=0;t<16;t++){let n=document.querySelector(`#channel-${t}-steps-container`);n||(n=document.createElement("div"),n.id=`channel-${t}-steps-container`,n.classList.add("steps-container"),document.body.appendChild(n)),n.innerHTML="";for(let o=0;o<64;o++){const c=document.createElement("button");c.classList.add("step-button"),c.id=`Sequence${e}-ch${t}-step-${o}`,c.addEventListener("click",(()=>{let n=window.unifiedSequencerSettings.getStepState(e,t,o);console.log(`[updateSpecificStepUI] [getStepState applied] Step button clicked: Sequence ${e}, Channel ${t}, Step ${o}, Current State: ${n}`),window.unifiedSequencerSettings.updateStepState(e,t,o,!n),console.log(`[updateSpecificStepUI] Step button clicked: Sequence ${e}, Channel ${t}, Step ${o}, New State: ${!n}`),updateSpecificStepUI(e,t,o)})),n.appendChild(c)}}}));
const mainContainer=document.getElementById("app"),channelTemplateContainer=document.querySelector(".channel-template"),channelTemplate=channelTemplateContainer.querySelector(".channel"),quickPlayButtons=[];let currentActiveIndex=null;const quickPlayContainer=document.createElement("div");function setActiveSequence(e){null!==currentActiveIndex&&currentActiveIndex!==e&&(console.log(`Deactivating previously active sequence ${currentActiveIndex}`),quickPlayButtons[currentActiveIndex].classList.add("inactive")),quickPlayButtons[e].classList.remove("inactive"),quickPlayButtons.forEach((t=>{t!==quickPlayButtons[e]&&t.classList.add("inactive")})),currentActiveIndex=e}function updateActiveQuickPlayButton(){quickPlayButtons.forEach((e=>{e.classList.remove("active")}));quickPlayButtons[currentSequence].classList.add("active")}function insertQuickPlayButtons(){const e=document.getElementById("continuous-play"),t=document.getElementById("quick-play-button");if(e&&t)for(let n=0;n<16;n++){const c=createQuickPlayButton(n);e.parentNode.insertBefore(c,t)}else console.log("QUICKPLAY BUTTONS TEMPORARILY REMOVED UNTIL THEY CAN BE FIXED")}function loadAndDisplaySequence(e){currentSequence=e,console.log(`[loadAndDisplaySequence] currentSequence updated to:  ${e}`),loadSequence(e),document.getElementById("current-sequence-display").textContent=`Sequence ${currentSequence}`,updateActiveQuickPlayButton()}function createQuickPlayButton(e){const t=document.createElement("div");t.classList.add("quick-play-button","tooltip"),t.dataset.sequenceIndex=e,t.innerHTML=e;const n=document.createElement("span");return n.classList.add("tooltiptext"),n.innerHTML=`Quick Load Sequence ${e}<br><br>Right click to change button colour.`,t.appendChild(n),quickPlayButtons.push(t),t.addEventListener("click",(function(){setActiveSequence(e)})),t.addEventListener("contextmenu",(function(e){e.preventDefault(),showColorPicker(e,t)})),t}quickPlayContainer.id="quickplay-container",quickPlayContainer.style.display="flex",quickPlayContainer.style.justifyContent="center",quickPlayContainer.style.marginBottom="20px",insertQuickPlayButtons(),quickPlayButtons.forEach((e=>{e.addEventListener("click",(()=>{loadAndDisplaySequence(parseInt(e.dataset.sequenceIndex,10))}))})),quickPlayButtons.forEach((e=>e.classList.add("inactive")));for(let e=0;e<=15;e++){let t=channelTemplate.cloneNode(!0);t.id=`channel-${e}`,mainContainer.appendChild(t)}channelTemplateContainer.remove();const setupCompleteEvent=new Event("setupComplete");window.dispatchEvent(setupCompleteEvent);
let isCopyPasteEvent=!1,copiedData=null;function validateAndUpdateUI(e){isValidSequence(window.unifiedSequencerSettings.getSequenceSettings(e))?(updateUIForSequence(e)):console.error(`[copyPasteDebug] Invalid sequence settings for sequence index: ${e}`)}function isValidSequence(e){if(!e||"object"!=typeof e)return console.log("[copyPasteDebug] Sequence is not an object."),!1;for(let t in e){if(!isValidChannel(e[t]))return console.log(`[copyPasteDebug] Invalid channel data in sequence: ${t}`),!1}return console.log("[copyPasteDebug] Sequence is valid for paste."),!0}function isValidChannel(e){return e&&Array.isArray(e.steps)&&"boolean"==typeof e.mute&&"string"==typeof e.url}function showConfirmationTooltip(e){const t=document.createElement("div");t.innerText=e,t.style.position="absolute",t.style.background="#333",t.style.color="white",t.style.padding="5px",t.style.borderRadius="5px",t.style.top="50%",t.style.left="50%",t.style.transform="translate(-50%, -50%)",t.style.zIndex="1000",document.body.appendChild(t),setTimeout((()=>{t.remove()}),3e3)}document.addEventListener("DOMContentLoaded",(function(){const e=document.getElementById("copy-sequence-settings"),t=document.getElementById("paste-button");e&&(console.log("[copyPasteDebug] Copy button clicked."),e.addEventListener("click",(function(){const e=window.unifiedSequencerSettings.getCurrentSequence(),n=window.unifiedSequencerSettings.getSequenceSettings(e);copiedData={type:"sequence",sequenceSettings:JSON.parse(JSON.stringify(n))},console.log("[copyPasteDebug] Sequence settings copied:",copiedData),t&&t.classList.add("flashing"),showConfirmationTooltip("[copyPasteDebug] Copied sequence settings. Select another sequence to paste to.")}))),t&&t.addEventListener("click",(function(){if(console.log("[copyPasteDebug] pasteButton clicked"),!copiedData||"sequence"!==copiedData.type)return void alert("No sequence data copied to paste!");const e=window.unifiedSequencerSettings.getCurrentSequence();console.log(`[copyPasteDebug] Current sequence index: ${e}`),window.unifiedSequencerSettings.setSequenceSettings(e,copiedData.sequenceSettings),console.log(`[copyPasteDebug] Sequence settings pasted to sequence index ${e}: ${JSON.stringify(copiedData)}`),updateUIForSequence(e),console.log(`[copyPasteDebug] updateUIForSequence called with sequence index: ${e}`),console.log(`[copyPasteDebug] Current sequence index according to the global object is now: ${window.unifiedSequencerSettings.getCurrentSequence()}`),this.classList.remove("flashing"),validateAndUpdateUI(e)}))}));
let totalSequenceCount = 16;
let isContinuousPlay = true;
function initializeNewSequence(e){let n=Array(16).fill().map((()=>[null].concat(Array(64).fill(!1)))),t=e+1;window.unifiedSequencerSettings.setCurrentSequence(t,n)}function loadSequence(e){let n=window.unifiedSequencerSettings.getSettings("projectSequences")[`Sequence${e}`];"object"==typeof n?(updateUIForSequence(e),Object.entries(n).forEach((([n,t])=>{const o=parseInt(n.replace("ch",""),10);updateChannelUI(e,o,t.steps)}))):console.error(`Sequence ${e} is not an object.`,n)}function loadNextSequence(){let e=window.unifiedSequencerSettings.getCurrentSequence();if(e<totalSequenceCount-1){const n=e+1;handleSequenceTransition(n),updateSequenceDisplay(n)}else console.warn("You've reached the last sequence.")}function updateChannelUI(e,n,t){const o=document.querySelector(`.channel[data-id="Channel-${n}"]`);if(!o)return void console.error(`Channel element not found for index: ${n}`);o.querySelectorAll(`.step-button[id^="Sequence${e}-ch${n}"]`).forEach(((e,n)=>{t[n]?e.classList.add("selected"):e.classList.remove("selected")}))}function updateSequenceDisplay(e){const n=document.getElementById("current-sequence-display");n&&(n.textContent="Sequence "+e),updateActiveQuickPlayButton()}function updateUIForSequence(e){const n=window.unifiedSequencerSettings.getSettings("masterSettings").projectSequences[`Sequence${e}`];e>=0&&e<64?channels.forEach(((t,o)=>{const c=t.querySelectorAll(".step-button"),u=t.querySelectorAll(".toggle-mute");n&&n[`ch${o}`]&&n[`ch${o}`].steps?(c.forEach((e=>e.classList.remove("selected"))),u.forEach((e=>e.classList.remove("toggle-mute"))),n[`ch${o}`].steps.forEach(((e,n)=>{e&&(c[n]?(c[n].classList.add("selected")):console.error(`[SeqDebug][debugging Step Button IDs][updateUIForSequence] Step Button not found at Position: ${n} in Channel: ${o}`))}))):console.error(`[SeqDebug][debugging Step Button IDs][updateUIForSequence] Missing step data for Channel: ${o} in Sequence: ${e}`)})):console.error("[SeqDebug][debugging Step Button IDs] [updateUIForSequence] Invalid sequence number:",e)}function changeSequence(e){console.log("changeSequence entered"),currentSequence=e,onSequenceOrDataChange()}function updateStep(e,n,t){console.log("updateStep entered"),channelSettings[e][n]=t,window.unifiedSequencerSettings.updateStepState(currentSequence,e,n,t),console.log(`updateStepState called with sequence: ${currentSequence}, channelIndex: ${e}, stepIndex: ${n}, state: ${t}`)}document.addEventListener("DOMContentLoaded",(()=>{const e=document.getElementById("continuous-play");e.addEventListener("click",(()=>{isContinuousPlay=!isContinuousPlay,e.classList.toggle("selected",isContinuousPlay)}))})),window.addEventListener("setupComplete",(function(){loadAndDisplaySequence(0)})),document.getElementById("next-sequence").addEventListener("click",(function(){console.log("Next sequence button clicked."),loadNextSequence()})),document.getElementById("prev-sequence").addEventListener("click",(function(){console.log("Previous sequence button clicked.");let e=window.unifiedSequencerSettings.getCurrentSequence();if(console.log(`Current sequence before decrement: ${e}`),e>0){const n=e-1;console.log(`[SeqDebug] Calling handleSequenceTransition with sequence: ${n}`),handleSequenceTransition(n),updateSequenceDisplay(n)}else console.warn("You're already on the first sequence.")})),console.log("Initial channel settings:",window.unifiedSequencerSettings.getSettings("projectSequences"));



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////


const channelPlaybackBroadcast = new BroadcastChannel('channel_playback');

function emitMessage(type, data) {
    // Get the current time
    const currentTime = new Date().toISOString();
    // Log the message with the current time
    console.log(`[[scheduleNextStep] emitMessage] Message sent at ${currentTime}:`);
    // Emit the message
    channelPlaybackBroadcast.postMessage({ type: type, data: data });
}

function emitBar(bar) {
    emitMessage("bar", { bar: bar });
}

function emitBeat(beat, bar) {
    emitMessage("beat", { beat: beat, bar: bar });
}

function emitPause() {
    emitMessage("pause", {});
}

function emitResume() {
    emitMessage("resume", {});
}

function emitStop() {
    emitMessage("stop", {});
}

function emitPlay() {
    emitMessage("play", {});
    emitMessage("beat", { beat: beatCount, bar: barCount });
}


////////////////////////////////////////////////////////////////////////////////////////////

function setChannelVolume(e,n){console.log("{channelSettings.js} setChannelVolume: channelIndex:",e,"volume:",n);const a=document.querySelector(`.channel[data-id="Channel-${e}"]`);a.dataset.volume=n,updateChannelVolume(a)}function updateChannelVolume(e){console.log("{channelSettings.js} updateChannelVolume: channel:",e);const n=parseFloat(e.dataset.volume);gainNodes[parseInt(e.dataset.id.split("-")[1])].gain.value=n}
function setupLoadSampleModalButton(e,t){const n=e.querySelector(".load-sample-button");n.textContent=window.unifiedSequencerSettings.settings.masterSettings.channelURLs[t],updateModalButtonText(n,t),openModal(t,n)}function openModal(e,t){const n=createModal(),o=createModalContent();n.appendChild(o),o.appendChild(createTextParagraph("Enter an Ordinal ID to load a Bitcoin Audional:"));const a=createInputField("Enter ORD ID:");o.appendChild(a),o.appendChild(createTextParagraph("Or, enter an IPFS ID for an off-chain Audional:"));const d=createInputField("Enter IPFS ID:");o.appendChild(d),addInputListeners(a,d),o.appendChild(createButton("Load Sample ID",(()=>handleLoad(e,a,d,n,t)),"loadButton","Load Audio from ID")),o.appendChild(createButton("Cancel",(()=>document.body.removeChild(n)),"cancelButton","Close this window"));const l=createExternalLinkButton("Search Ordinal Audio Files","https://ordinals.hiro.so/inscriptions?f=audio&s=genesis_block_height&o=asc","searchButton","Search for audio files (Copy and paste the Ordinal ID to load a sample");o.appendChild(l),document.body.appendChild(n)}function createModal(){const e=document.createElement("div");return e.className="loadSampleModalButton",e}function createModalContent(){const e=document.createElement("div");return e.className="loadSampleModalButton-content",e}function updateModalButtonText(e,t){const n=window.unifiedSequencerSettings.settings.masterSettings.projectChannelNames[t];e.textContent=n||`Load new audience (${t})`}function createTextParagraph(e){const t=document.createElement("p");return t.textContent=e,t.className="loadSampleModalButton-text",t}function createInputField(e){const t=document.createElement("input");return t.type="text",t.placeholder=e,t.className="loadSampleModalButton-input",t}function addInputListeners(e,t){e.addEventListener("input",(()=>{t.disabled=!!e.value})),t.addEventListener("input",(()=>{e.disabled=!!t.value}))}function createButton(e,t,n,o){const a=document.createElement("div");a.className="tooltip";const d=document.createElement("button");d.textContent=e,d.addEventListener("click",t),d.className=n,a.appendChild(d);const l=document.createElement("span");return l.className="tooltiptext",l.textContent=o,a.appendChild(l),a}function handleLoad(e,t,n,o,a){let d;if(console.log(`[HTML Debugging] [handleLoad] Called with index: ${e}`),t.value)d="https://ordinals.com/content/"+t.value;else{if(!n.value)return void console.log("[HTML Debugging] [handleLoad] No input value found.");d="https://ipfs.io/ipfs/"+n.value}d=formatURL(d),fetchAudio(d,e).then((()=>{console.log(`[HTML Debugging] [handleLoad] Audio loaded for channel ${e}: ${d}`),window.unifiedSequencerSettings.addChannelURL(e,d)})).catch((e=>{console.error(`[HTML Debugging] [handleLoad] Error loading audio for URL ${d}:`,e)})),document.body.removeChild(o),console.log(`[HTML Debugging] [handleLoad] Modal removed for channel ${e}`)}function createExternalLinkButton(e,t,n,o){const a=document.createElement("div");a.className="tooltip";const d=document.createElement("button");d.textContent=e,d.className=n,d.addEventListener("click",(()=>window.open(t,"_blank"))),a.appendChild(d);const l=document.createElement("span");return l.className="tooltiptext",l.textContent=o,a.appendChild(l),a}
window.addEventListener("DOMContentLoaded", (e) => {
    channels.forEach(((e, t) => {
        e.dataset.id = `Channel-${t}`;
        const n = audioContext.createGain();
        n.gain.value = 1,
        n.connect(audioContext.destination),
        gainNodes[t] = n;
        const o = e.querySelector(".mute-button");
        o.addEventListener("click", (() => {
            console.log(`Mute button clicked for Channel-${t}`);
            const n = o.classList.toggle("selected");
            updateMuteState(e, n),
            updateDimState(e, t)
        }));
        const c = e.querySelector(".solo-button");
        c.addEventListener("click", (() => {
            soloedChannels[t] = !soloedChannels[t],
            c.classList.toggle("selected", soloedChannels[t]),
            channels.forEach(((e, n) => {
                t === n ? updateMuteState(e, !1) : (updateMuteState(e, soloedChannels[t]), updateDimState(e, n))
            }))
        }));
        const l = e.querySelector(".clear-button");
        let a;
        e.querySelector(".clear-confirm"),
        l.addEventListener("click", (n) => {
            if (n.stopPropagation(),
            l.classList.contains("flashing")) {
                e.querySelectorAll(".step-button").forEach((e => {
                    e.classList.remove("selected")
                }));
                let n = Array(64).fill(!1);
                for (let e = 0; e < n.length; e++)
                    window.unifiedSequencerSettings.updateStepState(currentSequence, t, e, n[e]);
                clearTimeout(a),
                l.classList.remove("flashing")
            } else
                l.classList.add("flashing"),
                a = setTimeout((() => {
                    l.classList.remove("flashing")
                }), 2e3)
        }),
        document.addEventListener("click", (e) => {
            !l.contains(e.target) && l.classList.contains("flashing") && (clearTimeout(a),
            l.classList.remove("flashing"))
        });
        const s = e.querySelector(".load-sample-button");

        function i(e) {
            const t = document.querySelector(".custom-context-menu");
            t && !t.contains(e.target) && r()
        }

        function d(e, t) {
            const n = document.createElement("div");
            return n.textContent = e,
            Object.assign(n.style, {
                padding: "5px 10px",
                cursor: "pointer"
            }),
            n.addEventListener("mouseenter", (() => n.style.backgroundColor = "#f0f0f0")),
            n.addEventListener("mouseleave", (() => n.style.backgroundColor = "lightgray")),
            n.addEventListener("click", t),
            n
        }

        function r() {
            const e = document.querySelector(".custom-context-menu");
            e && e.remove()
        }

        function u() {
            const e = document.querySelector(".channel-naming-modal");
            e && document.body.removeChild(e)
        }
    
s.addEventListener("contextmenu",(e=>{console.log("Right-click on loadSampleButton"),e.preventDefault(),function(e,t,n,o,c){console.log("Creating custom context menu"),r();const l=function(e,t){const n=document.createElement("div");return n.className="custom-context-menu",Object.assign(n.style,{position:"absolute",top:`${t}px`,left:`${e}px`,backgroundColor:"lightgray",color:"black",padding:"10px",border:"1px solid #ddd",borderRadius:"5px",boxShadow:"0px 2px 5px rgba(0,0,0,0.2)"}),n}(t,n),a=d("Add User Channel Name",(()=>{!function(e){u();const t=document.createElement("div");t.className="channel-naming-modal";const n=document.createElement("input");n.type="text",n.placeholder="Give this channel a name",n.className="channel-name-input";const o=document.createElement("button");o.textContent="Submit",o.onclick=()=>{n.value&&window.unifiedSequencerSettings.setProjectChannelName(e,n.value),u()};const c=document.createElement("button");c.textContent="Cancel",c.onclick=u,t.appendChild(n),t.appendChild(o),t.appendChild(c),document.body.appendChild(t),document.addEventListener("click",(e=>{t.contains(e.target)||e.target.matches(".load-sample-button")||u()}),{capture:!0,once:!0})}(o),r()})),s=d("Copy Ordinal ID",(()=>{!function(e){const t=window.unifiedSequencerSettings.channelURLs(e);t?navigator.clipboard.writeText(t).then((()=>console.log("Full URL copied:",t))).catch((e=>console.error("Error copying URL:",e))):console.log("No URL found for channel:",e)}(o),console.log("Copy Ordinal ID clicked"),r()})),p=d("Copy Channel Settings (coming soon)",(()=>{console.log("Copy Channel Settings clicked"),r()})),g=d("Set Channel Colour",(()=>{console.log("Set Channel Colour option selected"),function(e,t){console.log("showColorPicker function called inside channelsForEach.js");const n=["#FF0000","#00FF00","#0000FF","#FFFF00","#00FFFF","#FF00FF","#808080","#FFFFFF","#FFA500","#800080","#008080","#000080","#800000","#008000","#FFC0CB","#D2691E"],o=document.createElement("div");o.style.position="absolute",o.style.display="grid",o.style.gridTemplateColumns="repeat(4, 1fr)",o.style.gap="1px";const c=n.length/4*20,l=e.clientY-c,a=e.clientX;console.log(`Color picker position - Top: ${l}px, Left: ${a}px`),o.style.top=l+"px",o.style.left=a+"px",n.forEach((e=>{const n=document.createElement("div");n.style.width="20px",n.style.height="20px",n.style.backgroundColor=e,n.addEventListener("click",(function(){console.log(`Color selected: ${e}`),t.style.backgroundColor=e,t.className=t.className.replace(/\bcolor-[^ ]+/g,""),t.classList.add(`color-${e.replace("#","")}`),o.remove()})),o.appendChild(n)})),document.body.appendChild(o),console.log("Color picker appended to the body. Check if it is visible in the DOM."),o.addEventListener("click",(function(e){e.stopPropagation()})),setTimeout((()=>{document.addEventListener("click",(function e(){console.log("Global click detected. Removing color picker."),o.remove(),document.removeEventListener("click",e)}))}),0),setTimeout((()=>{console.log("Removing color picker after 2 seconds."),o.remove()}),5e3)}(e,c),r()})),m=d("Paste Ordinal ID",(()=>{!function(e){navigator.clipboard.readText().then((t=>{if(isValidURL(t)){let n=[...window.unifiedSequencerSettings.settings.masterSettings.channelURLs];n[e]=t,window.unifiedSequencerSettings.setChannelURLs(n),console.log("Pasted full URL:",t)}else console.error("Invalid URL format.")})).catch((e=>console.error("Error pasting URL:",e)))}(o),r()})),h=d("Paste Channel Settings (coming soon)",(()=>{!function(e){navigator.clipboard.readText().then((t=>{let n=JSON.parse(t);window.unifiedSequencerSettings.setChannelSettings(e,n),console.log("Pasted Channel Settings:",n)})).catch((e=>console.error("Error pasting Channel Settings:",e)))}(o),r()}));l.appendChild(a),l.appendChild(g),l.appendChild(s),l.appendChild(m),l.appendChild(p),l.appendChild(h),document.body.appendChild(l),setTimeout((()=>{document.addEventListener("click",i,{capture:!0,once:!0})}),0)}(e,e.pageX,e.pageY,t,s)}))})),console.log("channelsForeach.js entered"),channels.forEach(((e,t)=>{}))});
// Function to create step buttons for each channel in the sequence
function createStepButtonsForSequence() {
    // Loop through each channel
    channels.forEach(((channel, index) => {
        // Find the steps container for the current channel
        const stepsContainer = channel.querySelector(".steps-container");
        // Clear the existing content of the steps container
        stepsContainer.innerHTML = "";

        // Get the current sequence
        let currentSequence = window.unifiedSequencerSettings.settings.masterSettings.currentSequence;

        // Loop through each step (total 64 steps)
        for (let step = 0; step < 64; step++) {
            // Create a button element for the step
            const stepButton = document.createElement("button");
            // Add CSS class to the button
            stepButton.classList.add("step-button");
            // Set the ID for the button based on sequence, channel, and step
            stepButton.id = `Sequence${currentSequence}-ch${index}-step-${step}`;
            // Add click event listener to the button
            stepButton.addEventListener("click", (() => {
                // Get the current state of the step
                let stepState = window.unifiedSequencerSettings.getStepState(currentSequence, index, step);
                // Update the step state (toggle)
                window.unifiedSequencerSettings.updateStepState(currentSequence, index, step, !stepState);
                // Toggle the 'selected' class for the button
                if (stepButton.classList.toggle("selected")) {
                    // If button becomes selected, add color class or set background color
                    const colorClass = channel.querySelector(".load-sample-button").className.match(/\bcolor-[^ ]+/);
                    if (colorClass) {
                        stepButton.classList.add(colorClass[0]);
                    } else {
                        stepButton.style.backgroundColor = "var(--accent-color)";
                    }
                } else {
                    // If button becomes unselected, remove classes and reset background color
                    stepButton.classList.remove(...stepButton.classList);
                    stepButton.classList.add("step-button");
                    stepButton.style.backgroundColor = "";
                }
                // Update UI for the specific step
                updateSpecificStepUI(currentSequence, index, step);
            }));
            // Append the button to the steps container
            stepsContainer.appendChild(stepButton);
        }
        // Log completion message to console
        console.log(`[createStepButtonsForSequence] Completed creating step buttons for Channel ${index} in Sequence ${currentSequence}.`);
    }));
}

// Event listener for DOMContentLoaded event to call the function when the document is fully loaded
document.addEventListener("DOMContentLoaded", createStepButtonsForSequence);

let totalNumberOfSequences=16;



function handleStep(element, controller, step) {
    // console.log("handleStep entered");
    let isMuted = "true" === element.dataset.muted;
    if (controller.toggleMuteSteps.includes(step)) {
        isMuted = !isMuted;
        element.dataset.muted = isMuted ? "true" : "false";
        updateMuteState(element, isMuted);
        console.log("Mute toggled by the handleStep function");
    }
    return isMuted;
}

// RENDER REMOVED FOR TESTING

// function renderPlayhead(elements, currentStep) {
//     // console.log("renderPlayhead entered");
//     elements.forEach((element, index) => {
//         element.classList.remove("playing");
//         element.classList.remove("triggered");
//         if (index === currentStep) {
//             element.classList.add("playing");
//         }
//         if (element.classList.contains("selected")) {
//             element.classList.add("triggered");
//         }
//     });
// }

// Create a new Map to store audio buffers
const audioBuffers = new Map;

// Function to extract ID from a URL
function getIDFromURL(url) {
    console.log("[HTML Debugging] getIDFromURL entered");
    // Split the URL by '/'
    const parts = url.split("/");
    // Get the last part of the URL which should be the ID
    return parts[parts.length - 1];
}

// Function to convert base64 string to array buffer
function base64ToArrayBuffer(base64String) {
    console.log("[HTML Debugging] [base64ToArrayBuffer] Entered function. Base64 sample:", base64String.substring(0, 100));
    // Decode the base64 string
    const decodedString = atob(base64String);
    // Get the length of the decoded string
    const length = decodedString.length;
    // Create a new Uint8Array with the length of the decoded string
    const uintArray = new Uint8Array(length);
    // Loop through the decoded string and assign values to the Uint8Array
    for (let i = 0; i < length; i++) {
        uintArray[i] = decodedString.charCodeAt(i);
    }
    console.log(`[HTML Debugging] [base64ToArrayBuffer] Generated Uint8Array length: ${uintArray.length}`);
    // Return the ArrayBuffer of the Uint8Array
    return uintArray.buffer;
}

// Function to decode audio data
const decodeAudioData = (arrayBuffer) => {
    // Extract the first 20 bytes of the ArrayBuffer
    let first20Bytes = new Uint8Array(arrayBuffer.slice(0, 20));
    console.log("[HTML Debugging] [decodeAudioData] ArrayBuffer first 20 bytes:", first20Bytes.join(", "));
    
    // Return a Promise for decoding the audio data
    return new Promise(((resolve, reject) => {
        // Decode the audio data using Web Audio API's decodeAudioData
        audioContext.decodeAudioData(arrayBuffer, 
            // On success, resolve the promise with the decoded audio data
            (decodedData) => {
                console.log("[HTML Debugging] [decodeAudioData] Audio data decoded successfully.");
                resolve(decodedData);
            },
            // On error, reject the promise with the error
            (error) => {
                console.error("[HTML Debugging] [decodeAudioData] Detailed Error:", {
                    message: error.message,
                    code: error.code
                });
                reject(error);
            }
        );
    }));
};

// Function to fetch audio data asynchronously, unchanged from original code
const fetchAudio = async (url, index, button) => {
    // Format the URL
    const formattedUrl = formatURL(url);
    console.log("[HTML Debugging] [fetchAudio] Entered function. URL:", formattedUrl, "Channel Index:", index);

    try {
        // Fetch the audio file
        const response = await fetch(formattedUrl);
        const contentType = response.headers.get("Content-Type");
        let audioBuffer;

        // Check if response contains HTML content
        if (contentType && contentType.includes("text/html")) {
            // If HTML content, import audio data
            const htmlContent = await response.text();
            const audioData = await importHTMLAudioData(htmlContent, index);
            if (!audioData) return;
            // Convert base64 data to array buffer or fetch the audio data
            audioBuffer = audioData.startsWith("data:") ? base64ToArrayBuffer(audioData.split(",")[1]) :
                await fetch(audioData).then(response => response.arrayBuffer());
        } else {
            // If not HTML content, directly convert to array buffer
            audioBuffer = await response.arrayBuffer();
        }

        // Decode the audio data
        const decodedAudioBuffer = await decodeAudioData(audioBuffer);
        // Store the audio buffer
        audioBuffers.set(formattedUrl, decodedAudioBuffer);
        console.log("[HTML Debugging] [fetchAudio] Audio buffer stored.");
    } catch (error) {
        console.error("[HTML Debugging] [fetchAudio] Error:", error);
    }
};

// Assuming audioContext, audioBuffers, window.unifiedSequencerSettings are globally defined

let currentStepIndex = 0; 


// Centralizes sequencer settings access
const sequencerSettings = {
  get BPM() { return window.unifiedSequencerSettings.getBPM(); },
  getCurrentSequence() { return window.unifiedSequencerSettings.getCurrentSequence(); },
  getSequenceSettings(sequence) { return window.unifiedSequencerSettings.getSequenceSettings(sequence); },
  getChannelURL(index) { return window.unifiedSequencerSettings.getChannelURL(index); }
};

function scheduleAudioEvent(time) {
    const oscillator = audioContext.createOscillator();
    oscillator.connect(audioContext.destination);
    oscillator.start(time);
    oscillator.stop(time + 0.1);
}

function startSequencer() {
    if (audioContext.state === 'suspended') {
        audioContext.resume().then(startScheduler);
    } else {
        startScheduler();
    }
}

function startScheduler() {
    isPaused = false;
    const startTime = audioContext.currentTime;
    scheduleNextStep(startTime);
}

function scheduleNextStep(startTime) {
    if (isPaused) return;

    const stepDuration = 60 / sequencerSettings.BPM / 4;
    const nextStepTime = startTime + stepDuration * currentStepIndex;
    const currentTime = audioContext.currentTime;

    if (nextStepTime <= currentTime) {
        playStep();
        currentStepIndex++;
    }

    const timeUntilNextStep = Math.max(nextStepTime - currentTime, 0);
    timeoutId = setTimeout(() => scheduleNextStep(startTime), timeUntilNextStep * 1000);
}

// // Optimized scheduler function
// function scheduleNextStep() {
//     if (isPaused) {
//         console.log("Sequencer is paused/stopped. Not scheduling the next step.");
//         return;
//     }
//     const currentBPM = window.unifiedSequencerSettings.getBPM();
//     const stepDuration = 60 / currentBPM / 4; // Assuming 4 steps per beat
//     const nextStepDelay = stepDuration * 1000 - (audioContext.currentTime * 1000 % (stepDuration * 1000));

//     setTimeout(() => {
//         requestAnimationFrame(playStep);
//         scheduleNextStep();
//     }, nextStepDelay);
// }


function playStep() {
    if (typeof channelIndex !== 'undefined') {
        channelPlaybackBroadcast.postMessage({ action: 'play', channelIndex });
    } else {
        console.log(`Skipped posting message for undefined channelIndex at step ${currentStepIndex}`);
    }

    const currentSequence = sequencerSettings.getCurrentSequence();

    for (let channelIndex = 0; channelIndex < 16; channelIndex++) {
        const channelSettings = sequencerSettings.getSequenceSettings(currentSequence)[`ch${channelIndex}`];
        if (!channelSettings) continue;

        if (channelSettings.steps[currentStepIndex] && !channelSettings.mute) {
            const channelURL = sequencerSettings.getChannelURL(channelIndex);
            const audioBuffer = audioBuffers.get(channelURL);
            if (audioBuffer) {
                playTrimmedAudio(channelIndex, audioBuffer, channelURL);
                channelPlaybackBroadcast.postMessage({ action: 'play', channelIndex });
            }
        }
    }

    handleStepTransition();
}

function handleStepTransition() {
    currentStepIndex = (currentStepIndex + 1) % 64;
    if (document.getElementById("continuous-play").checked && currentStepIndex === 0) {
        handleSequenceTransition();
    }
}

function handleSequenceTransition() {
    // Assuming totalNumberOfSequences is defined
    const newSequence = (sequencerSettings.getCurrentSequence() + 1) % totalNumberOfSequences;
    window.unifiedSequencerSettings.setCurrentSequence(newSequence);
}

function pauseScheduler() {
    clearTimeout(timeoutId);
    isPaused = true;
    if (audioContext.state === 'running') {
        audioContext.suspend();
    }
}

function stopScheduler() {
    clearTimeout(timeoutId);
    isPaused = true;
    currentStepIndex = 0;
    resetPlayheadUI();
}

function resetPlayheadUI() {
    const stepButtons = document.querySelectorAll('.step-button');
    stepButtons.forEach(button => button.classList.remove("playing", "triggered"));
}


function handleSequenceTransition(sequence) {

    // Set current sequence to provided sequence
    window.unifiedSequencerSettings.setCurrentSequence(sequence);
    // Log sequence set message

    // Update current sequence display if available
    const currentSequenceDisplay = document.getElementById("current-sequence-display");
    if (currentSequenceDisplay) {
        currentSequenceDisplay.innerHTML = `Sequence: ${sequence}`;
    }

    // Reset counters for new sequence
    resetCountersForNewSequence();
    // Create step buttons for the new sequence
    createStepButtonsForSequence();

    // Delayed UI update for the new sequence
    setTimeout(() => {
        updateUIForSequence(sequence);
        // console.log(`[SeqDebug][handleSequenceTransition][stepHandling] UI updated for sequence ${sequence} at ${(new Date).toLocaleTimeString()}`);
    }, 100);
}

function resetCountersForNewSequence() {
    // Reset beat count, bar count, current step, and total step count
    beatCount = 0;
    barCount = 0;
    currentStep = 0;
    totalStepCount = 0;
}


function resetStepLights() {
    const buttons = document.querySelectorAll('.step-button');
    buttons.forEach(button => {
        button.classList.remove('playing');
    });
    }




const presets={preset1:{name:"Preset 1",bpm:"105",channels:[{triggers:[],mute:!1,toggleMuteSteps:[],url:""},{triggers:[],mute:!1,toggleMuteSteps:[],url:""},{triggers:[],mute:!1,toggleMuteSteps:[],url:""},{triggers:[],mute:!1,toggleMuteSteps:[],url:""},{triggers:[],mute:!1,toggleMuteSteps:[],url:""},{triggers:[],mute:!1,toggleMuteSteps:[],url:""},{triggers:[],mute:!0,toggleMuteSteps:[],url:""},{triggers:[],mute:!1,toggleMuteSteps:[],url:""},{triggers:[],mute:!1,toggleMuteSteps:[],url:""},{triggers:[],mute:!1,toggleMuteSteps:[],url:""},{triggers:[],mute:!1,toggleMuteSteps:[],url:""},{triggers:[],mute:!1,toggleMuteSteps:[],url:""},{triggers:[],mute:!1,toggleMuteSteps:[],url:""},{triggers:[],mute:!1,toggleMuteSteps:[],url:""},{triggers:[],mute:!1,toggleMuteSteps:[],url:""},{triggers:[],mute:!1,toggleMuteSteps:[],url:""}]}};console.log("Initial Presets:",presets);

async function importHTMLAudioData(e,t){console.log("[importHTMLSampleData] Entered function with index: ",t);try{const t=new DOMParser,o=t.parseFromString(e,"text/html").querySelector("audio[data-audionalSampleName] source");if(o){const e=o.getAttribute("src");if(e.toLowerCase().startsWith("data:audio/wav;base64,")||e.toLowerCase().startsWith("data:audio/mp3;base64,"))return console.log("[importHTMLSampleData] Extracted base64 audio data."),e;console.error("[importHTMLSampleData] Audio data does not start with expected base64 prefix.")}else console.error("[importHTMLSampleData] Could not find the audio source element in the HTML content.")}catch(e){console.error("[importHTMLSampleData] Error parsing HTML content: ",e)}return null}


////////////////////////////////////////////////////////////////////////

function bufferToBase64(buffer) {
    console.log("bufferToBase64 entered");
    let base64String = "";
    const uint8Array = new Uint8Array(buffer);
    const byteLength = uint8Array.byteLength;
    console.log(`[HTML Debugging] [bufferToBase64] Buffer length: ${byteLength}`);
    for (let i = 0; i < byteLength; i++) {
        base64String += String.fromCharCode(uint8Array[i]);
    }
    const base64Encoded = window.btoa(base64String);
    console.log(`[HTML Debugging] [bufferToBase64] Converted to base64, length: ${base64Encoded.length}`);
    return base64Encoded;
}

function playSound(sequence, element, step) {
    // console.log("playSound entered");
    const channelIndex = getChannelIndex(element);
    console.log(`[playSound Debugging] [playSound] Processing channel index: ${channelIndex}`);
    const stepState = getStepState(sequence, channelIndex, step);
    // console.log(`[playSound Debugging] [playSound] setting stepState using getStepState to: ${stepState}`);
    if (!stepState) {
        console.log("[playSound Debugging] [playSound] Current step is not selected. Skipping playback.");
        return;
    }
    const audioUrl = getAudioUrl(channelIndex);
    // console.log("[playSound Debugging] [playSound] Audio URL:", audioUrl);
    const audioBuffer = getAudioBuffer(audioUrl);
    if (audioBuffer) {
        // console.log("[playSound Debugging] [playSound] Audio buffer:", audioBuffer);
        playTrimmedAudio(channelIndex, audioBuffer, audioUrl);
    } else {
        console.log("[playSound Debugging] [playSound] No audio buffer found for URL:", audioUrl);
    }
}

function getChannelIndex(element) {
    return parseInt(element.dataset.id.split("-")[1]);
}

function getStepState(sequence, channelIndex, step) {
    // console.log(`[playSound Debugging] [getStepState called] currentSequence: ${sequence}, channelIndex: ${channelIndex}, currentStep: ${step}`);
    return window.unifiedSequencerSettings.getStepState(sequence, channelIndex, step);
}

function getAudioUrl(channelIndex) {
    return typeof window.unifiedSequencerSettings.getprojectUrlforChannel === "undefined" ?
        (console.error(`[getAudioUrl] [ playSound ] URL not found for channel index: ${channelIndex}`), "defaultURL") :
        window.unifiedSequencerSettings.getprojectUrlforChannel(channelIndex);
}

function getAudioBuffer(url) {
    return audioBuffers.get(url);
}


// Improved global function to retrieve trim settings.
function getGlobalTrimSettings(channelIndex) {
    // console.log("[getGlobalTrimSettings] Entered for channel index:", channelIndex);
    const trimSettings = window.unifiedSequencerSettings.settings.masterSettings.trimSettings;

    if (!trimSettings || channelIndex < 0 || channelIndex >= trimSettings.length) {
        console.error("[getGlobalTrimSettings] Invalid channel index or trimSettings not found", channelIndex);
        return { startSliderValue: 0.01, endSliderValue: 100, totalSampleDuration: 1 }; // Provide default values
    }

    return trimSettings[channelIndex];
}

// Adjusted playTrimmedAudio function that handles trim settings correctly.
function playTrimmedAudio(channelIndex, audioBuffer, url) {
    // console.log("[playTrimmedAudio] Entered for URL:", url);

    // Retrieve trim settings for the current channel.
    const trimSettings = getGlobalTrimSettings(channelIndex);
    let trimStart = trimSettings.startSliderValue / 100 * audioBuffer.duration;
    let trimEnd = trimSettings.endSliderValue / 100 * audioBuffer.duration;

    // Ensure trimStart and trimEnd are within valid range.
    trimStart = Math.max(0, Math.min(trimStart, audioBuffer.duration));
    trimEnd = Math.max(trimStart, Math.min(trimEnd, audioBuffer.duration));

    // Calculate the actual duration to play.
    const duration = trimEnd - trimStart;

    // Log the calculated values for debugging.
    // console.log(`[playTrimmedAudio] Channel: ${channelIndex}, TrimStart: ${trimStart}, Duration: ${duration}`);

    // Ensure duration is finite, otherwise, log an error and return early.
    if (!isFinite(trimStart) || !isFinite(duration)) {
        console.error("[playTrimmedAudio] Invalid trimStart or duration", {trimStart, duration});
        return;
    }

    // Play the audio with the calculated trim settings.
    const source = audioContext.createBufferSource();
    source.buffer = audioBuffer;
    source.connect(gainNodes[channelIndex]);
    gainNodes[channelIndex].connect(audioContext.destination);
    source.start(0, trimStart, duration);
}



function calculateTrimValues(channelIndex, audioBuffer) {
    const trimSettings = getGlobalTrimSettings(channelIndex);

    // Ensure that we have valid numeric values for startSliderValue and endSliderValue
    let trimStart = (Number(trimSettings.startSliderValue) || 0) / 100 * audioBuffer.duration;
    let trimEnd = (Number(trimSettings.endSliderValue) || 100) / 100 * audioBuffer.duration;

    // Correct any potential NaN values by setting to valid defaults
    trimStart = isNaN(trimStart) ? 0 : trimStart;
    trimEnd = isNaN(trimEnd) ? audioBuffer.duration : trimEnd;

    // Ensure trimEnd is not less than trimStart
    trimEnd = Math.max(trimStart, trimEnd);

    const duration = trimEnd - trimStart;
    return { trimStart, duration };
}

async function playAuditionedSample(url) {
    console.log("playAuditionedSample entered");
    try {
        const formattedURL = formatURL(url);
        const response = await fetch(formattedURL);
        const data = await response.json();
        if (data.audioData) {
            const arrayBuffer = base64ToArrayBuffer(data.audioData.split(",")[1]);
            if (!audioContext) {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                audioContext = new AudioContext();
            }
            const audioBuffer = await decodeAudioData(arrayBuffer);
            const source = audioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(audioContext.destination);
            source.start();
        } else {
            console.log("Audional data not found in response, attempting to fetch and parse content type.");
            const contentType = await fetchAndParseContentType(url);
            console.log(`Content type found: ${contentType}`);
        }
    } catch (error) {
        console.error("Error playing auditioned sample:", error);
    }
}

function togglePlayState(isPlaying, play, pauseButton, playButton) {
    console.log("togglePlayState entered");
    if (!isPlaying) {
        isPlaying = true;
        play();
        pauseButton.classList.add("selected");
        playButton.classList.remove("selected");
    } else {
        isPlaying = false;
        pauseButton.classList.remove("selected");
        playButton.classList.add("selected");
    }
}

function updateMuteState(element, isMuted) {
    console.log("updateMuteState entered");
    console.log("updateMuteState - isMuted: " + isMuted);
    const channelIndex = parseInt(element.dataset.id.split("-")[1]);
    element.dataset.muted = isMuted ? "true" : "false";
    element.querySelector(".mute-button").classList.toggle("selected", isMuted);
    channelMutes[channelIndex] = isMuted;
    gainNodes[channelIndex].gain.value = isMuted ? 0 : 1;
    updateDimState(element, channelIndex);
}

function toggleMute(element) {
    console.log("toggleMute entered");
    const channelIndex = parseInt(element.dataset.id.split("-")[1]);
    updateMuteState(element, !channelMutes[channelIndex], channelIndex);
    console.log("Mute has been toggled by the toggleMute function");
}


///////////////////////////////////////////////////////////////////////////////////



function updateProjectNameObserver(e){console.log("[observers] updateProjectNameObserver called with:",e),e&&e.masterSettings&&e.masterSettings.projectName&&(console.log("[observers] Updating Project Name UI:",e.masterSettings.projectName),updateProjectNameUI(e.masterSettings.projectName))}function updateBPMObserver(e){console.log("[observers] updateBPMObserver called with:",e),e&&e.masterSettings&&e.masterSettings.projectBPM&&(console.log("Updating BPM UI:",e.masterSettings.projectBPM),updateBPMUI(e.masterSettings.projectBPM))}function updateProjectURLsObserver(e){console.log("[observers] updateProjectURLsObserver called with:",e),e&&e.masterSettings&&e.masterSettings.projectURLs&&(console.log("Updating Project URLs UI:",e.masterSettings.projectURLs),unifiedSequencerSettings.updateAllLoadSampleButtonTexts(),updateProjectURLsUI(e.masterSettings.projectURLs))}function updateTrimSettingsObserver(e){console.log("[observers] updateTrimSettingsObserver called with:",e),e&&e.masterSettings&&e.masterSettings.trimSettings&&(console.log("Updating Trim Settings UI:",e.masterSettings.trimSettings),updateTrimSettingsUI(e.masterSettings.trimSettings))}function updateProjectChannelNamesObserver(e){console.log("[observers] updateProjectChannelNamesObserver called with:",e),e&&e.masterSettings&&e.masterSettings.projectChannelNames&&(console.log("Updating Project channel Names UI:",e.masterSettings.projectChannelNames),e.masterSettings.projectChannelNames.forEach(((e,t)=>{const r=document.querySelector(`#channel-name-${t}`);r&&(r.textContent=e||"Default Channel Name")})))}function updateProjectSequencesObserver(e){console.log("[observers] updateProjectSequencesObserver called with:",e),e&&e.masterSettings&&e.masterSettings.projectSequences&&(console.log("Updating Project Sequences UI:",e.masterSettings.projectSequences),updateProjectSequencesUI(e.masterSettings.projectSequences))}function registerObservers(){console.log("[observers] registerObservers called"),window.unifiedSequencerSettings?(window.unifiedSequencerSettings.addObserver(updateProjectNameObserver),window.unifiedSequencerSettings.addObserver(updateBPMObserver),window.unifiedSequencerSettings.addObserver(updateProjectURLsObserver),window.unifiedSequencerSettings.addObserver(updateTrimSettingsObserver),window.unifiedSequencerSettings.addObserver(updateProjectChannelNamesObserver),window.unifiedSequencerSettings.addObserver(updateProjectSequencesObserver),window.unifiedSequencerSettings.addObserver(updateCurrentSequenceObserver),window.unifiedSequencerSettings.addObserver(updateTotalSequencesObserver)):console.error("UnifiedSequencerSettings instance not found.")}function updateCurrentSequenceObserver(e){console.log("[Observer] updateCurrentSequenceObserver called with:",e),e&&e.masterSettings&&"number"==typeof e.masterSettings.currentSequence&&console.log("[Observer] Current Sequence changed:",e.masterSettings.currentSequence)}function updateTotalSequencesObserver(e){console.log("[Observer] updateTotalSequencesObserver called with:",e),e&&e.masterSettings&&Array.isArray(e.masterSettings.projectSequences)&&console.log("[Observer] Total number of Sequences changed:",e.masterSettings.projectSequences.length)}registerObservers();


let isPlaying = false;
let currentStep = 0;
let totalStepCount = 0;
let beatCount = 1;
let barCount = 1;
let sequenceCount = 1;
let currentSequence = 0;

const sequenceLength = 64;
const maxSequenceCount = 64;
const allSequencesLength = 4096;
const collectedURLs = Array(16).fill("");

let timeoutId;
let currentStepTime;
let startTime;
let stepDuration;
let pauseTime = 0;
let stopClickCount = 0;


// Get DOM elements
const playButton = document.getElementById("play");
const stopButton = document.getElementById("stop");
const saveButton = document.getElementById("save-button");

// Initialize audio-related variables
let gainNodes = Array(16).fill(null);
let isMuted = false;
let channelMutes = [];
let muteState = false;
let volumeStates = Array(16).fill(1);
let soloedChannels = Array(16).fill(false);

// Select all channel elements
const channels = document.querySelectorAll('.channel[id^="channel-"]');
const activeChannels = 16;

// Variables for clearing and confirming clicks
let clearClickedOnce = Array(channels.length).fill(false);
let clearConfirmTimeout = Array(channels.length).fill(null);

// Check if Web Audio API is supported
if (!audioContext) {
  try {
    window.AudioContext = window.AudioContext || window.webkitAudioContext;
    audioContext = new AudioContext();
  } catch (e) {
    console.warn("Web Audio API is not supported in this browser");
  }
}


function updateVolume(e,t){if(console.log("updateVolume entered"),soloedChannels.some((e=>e)))gainNodes[t].gain.value=soloedChannels[t]?1:0;else{const n=e.querySelector(".mute-button").classList.contains("selected");gainNodes[t].gain.value=n?0:1}}function updateDimState(e,t){console.log("updateDimState entered"),console.log(`updateDimState called for channel ${t}`);const n=window.unifiedSequencerSettings.getCurrentSequence(),o=e.querySelectorAll(`.step-button[id^="Sequence${n}-ch${t}"]`);0===gainNodes[t].gain.value?o.forEach((e=>e.classList.add("dimmed"))):o.forEach((e=>e.classList.remove("dimmed")))}if(document.addEventListener("click",(()=>{channels.forEach(((e,t)=>{if(clearClickedOnce[t]){e.querySelector(".clear-confirm").style.display="none",clearTimeout(clearConfirmTimeout[t]),clearClickedOnce[t]=!1}}))})),playButton&&stopButton){const t=document.querySelector("#channel-0 .step-button:nth-child(4n)");t&&t.classList.add("selected");const n=document.querySelector("#channel-1 .step-button:nth-child(1)");n&&n.classList.add("selected");const o=document.querySelector("#channel-1 .step-button:nth-child(6)");o&&o.classList.add("selected");let l=!1;function checkContinuousPlay()
{document.getElementById("continuous-play").checked&&totalStepCount>=4096&&(beatCount=0,barCount=0,currentStep=0,totalStepCount=0,document.getElementById("next-sequence").click())}

// if (window.self !== window.top) { // Check if in an iframe
    let presetLoaded = false; // Flag to track if the preset file has been loaded

    // Add a global click listener that toggles playback
    window.addEventListener("click", async (event) => {
        event.stopPropagation(); // Prevent event propagation

        console.log("[playbackDebug] Overlay clicked. State of audioContext:", audioContext.state);

        if (!presetLoaded) {
            try {
                const response = await fetch('BasedSong1.json'); // Adjust the path as needed
                const json = await response.json();
                console.log("[Load Process] Settings loaded:", json);

                // Assuming window.unifiedSequencerSettings exists and is ready to use
                window.unifiedSequencerSettings.loadSettings(json);
                console.log("[Load Process] Settings applied to the sequencer");

                // Process channel URLs for audio loading
                if (json.channelURLs && Array.isArray(json.channelURLs)) {
                    await processChannelURLs(json.channelURLs);
                }

                presetLoaded = true; // Mark the preset as loaded

            } catch (error) {
                console.error("[Load Process] Error loading or applying settings:", error);
            }
        }

        if (audioContext && audioContext.state === 'suspended') {
            await audioContext.resume();
            console.log("[AudioContext] AudioContext resumed.");
        }

        if (isPlaying) {
            stopScheduler();
            emitStop(); // Assume this function signals the stop event
            isPlaying = false;
            console.log("[Playback] Playback stopped.");
        } else {
            startScheduler();
            emitPlay(); // Assume this function signals the play event
            isPlaying = true;
            console.log("[Playback] Playback started.");
        }
    }, true); // Use capture phase to ensure the event is handled first




playButton.addEventListener("click", () => {
    console.log("[playbackDebug] Play button clicked. State of audioContext:", audioContext.state);
    
    // Check if the sequencer is already playing
    if (isPlaying) {
        // Logic to toggle pause/resume
        if (l) {
            resumeScheduler();
            emitResume();
            l = false;
        } else {
            pauseScheduler();
            emitPause();
            l = true;
        }
    } else {
        // Start playback if not already playing
        startScheduler();
        emitPlay();
        playButton.classList.add("selected");
        stopButton.classList.remove("selected");
        isPlaying = true;
        l = false;
    }

    // Continuous play check and preset loading
    let continuousPlay = document.getElementById("continuous-play").checked;
    if (continuousPlay && totalStepCount >= 4096) {
        resetSequenceProgress(); // Encapsulate sequence progress reset logic in a function for clarity
        loadNextPreset(); // Encapsulate preset loading logic in a function for clarity
    }
});

function resetSequenceProgress() {
    beatCount = 0;
    barCount = 0;
    sequenceCount = 0;
    currentStep = 0;
    totalStepCount = 0;
    sequenceCount++;
    if (sequenceCount > 64) {
        sequenceCount = 1;
    }
}

function loadNextPreset() {
    loadPreset(`preset${sequenceCount}`);
    checkContinuousPlay();
}

// Correct setup for the stopButton event listener
stopButton.addEventListener("click", () => {
    if (isPlaying) { // Assuming isPlaying is a flag indicating whether playback is active
        stopScheduler(); // Assuming this function correctly stops the playback
        emitStop(); // Assuming this function emits a stop event or similar action
        stopButton.classList.add("selected");
        playButton.classList.remove("selected");
        isPlaying = false; // Update the isPlaying flag to false
        // Assuming 'l' is a variable used in your logic, reset it as well
        l = false; // Resetting 'l' based on your logic, ensure 'l' is declared and used correctly
        // Reset playback related variables
        beatCount = 0;
        barCount = 0;
        sequenceCount = 0;
        currentStep = 0;
        totalStepCount = 0;
        resetStepLights(); // Assuming this function resets UI elements related to step lights
    }
}, false); // Adding 'false' for useCapture parameter as a best practice
}

const loadPreset=e=>{console.log("index.js loadPreset entered"),console.log(`index.js loadPreset: Loading preset: ${e}`);const t=presets[e];t?(channels.forEach(((e,n)=>{const o=t.channels[n];if(!o)return void console.warn(`No preset data for channel index: ${n}`);const l=window.unifiedSequencerSettings.getChannelURL(n),{steps:a,mute:s}=o;if(l){const e=document.querySelector(`.channel[data-id="Channel-${n}"] .load-sample-button`);fetchAudio(l,n,e).then((()=>{const t=getAudioTrimmerInstanceForChannel(n);t&&t.loadSampleFromURL(l).then((()=>{const l=o.trimSettings?.startSliderValue||.01,a=o.trimSettings?.endSliderValue||t.totalSampleDuration;t.setStartSliderValue(l),t.setEndSliderValue(a),window.unifiedSequencerSettings.setTrimSettings(n,l,a),updateLoadSampleButtonText(n,e)}))}))}a.forEach((e=>{const t=document.querySelector(`.channel[data-id="Channel-${n}"] .step-button:nth-child(${e})`);t&&t.classList.add("selected")}));const u=document.querySelector(`.channel[data-id="Channel-${n}"]`);u&&(updateMuteState(u,s),u.classList.add("ordinal-loaded"))})),console.log(e),loadChannelSettingsFromPreset(presets[e]),console.log("loadPreset: After loadPreset, gainNodes values:",gainNodes.map((e=>e.gain.value)))):console.error("Preset not found:",e)};function updateLoadSampleButtonText(e,t){console.log("updateLoadSampleButtonText entered"),console.log(`[updateLoadSampleButtonText] Called for channel index: ${e}`);const n=window.unifiedSequencerSettings.channelURLs(e);console.log(`[updateLoadSampleButtonText] Loaded URL for channel ${e}: ${n}`),n?(t.textContent=n,console.log(`[updateLoadSampleButtonText] Button text updated to: ${n}`)):(t.textContent="Load New Audional",console.log("[updateLoadSampleButtonText] Default text set for button"))}function testUpdateLoadSampleButtonText(){console.log("[testUpdateLoadSampleButtonText] Function entered");document.querySelectorAll(".channel").forEach(((e,t)=>{const n=e.querySelector(".load-sample-button");n?(n.textContent=`Channel ${t+1}`,console.log(`[testUpdateLoadSampleButtonText] Button text updated for channel ${t+1}`)):console.log(`[testUpdateLoadSampleButtonText] No loadSampleButton found for channel ${t+1}`)}))}console.log("index.js loaded");

// Global instance
// const sequencerSettings = new UnifiedSequencerSettings();
// Get the container element with id "drum-machine"
const appContainer = document.getElementById("drum-machine");

// Add event listener to the container for click events
appContainer.addEventListener("click", () => {
    // When clicked, resume the audio context
    audioContext.resume().then(() => {
        console.log("Playback resumed successfully");
    });
});

// Add event listener when the DOM content is loaded
document.addEventListener("DOMContentLoaded", () => {
    // Get elements by their respective ids
    const saveButton = document.getElementById("save-button");
    const loadFileInput = document.getElementById("load-file-input");
    const newLoadButton = document.getElementById("new-load-button");
    const loadOptions = document.getElementById("loadOptions");
    const loadJson = document.getElementById("loadJson");
    let loadClicked = false;




    // Event listener for the "New/Load" button
    newLoadButton.addEventListener("click", () => {
        console.log("[Save/Load debug] Load button clicked");
        // If load button was not clicked before, remove animation
        if (!loadClicked) {
            newLoadButton.classList.remove("smooth-wave");
            newLoadButton.style.animation = "none";
            loadClicked = true;
        }
        // Toggle display of load options
        loadOptions.style.display = loadOptions.style.display === "none" || loadOptions.style.display === "" ? "block" : "none";
    });

    // Event listener for the "Load JSON" button
    loadJson.addEventListener("click", () => {
        console.log("[Save/Load debug] loadJson clicked");
        // Simulate click on the file input element
        loadFileInput.click();
        // Hide load options
        loadOptions.style.display = "none";
    });

    // Event listener for the change event on the file input
    loadFileInput.addEventListener("change", async () => {
        console.log("[Save/Load debug] loadFileInput change event");
        // Get the selected file
        let file = loadFileInput.files[0];
        let reader = new FileReader();
        reader.onload = async function (event) {
            console.log("File read start");
            // Parse the JSON content of the file
            let data = JSON.parse(event.target.result);
            console.log("[loadFileInput] File content:", data);
            // Load settings from the parsed JSON
            window.unifiedSequencerSettings.loadSettings(data);
            // If channel URLs are present, process each URL
            if (data.channelURLs && Array.isArray(data.channelURLs)) {
                await processChannelURLs(data.channelURLs);
            }
        };
        // Read the file as text
        reader.readAsText(file);
    });
});

// Dedicated function to process channel URLs
async function processChannelURLs(channelURLs) {
    for (let i = 0; i < channelURLs.length; i++) {
        const url = channelURLs[i];
        if (url) {
            // Assuming fetchAudio is already implemented and adapted for this context
            await fetchAudio(url, i);
        }
    }
}


// Event listener for the "message" event
window.addEventListener("message", (event) => {
    // Handle message event
});

// Event listener for the "click" event on the close button
document.querySelector(".close-button").addEventListener("click", () => {
    console.log("Close button clicked");
    // Hide the audio trimmer modal
    document.getElementById("audio-trimmer-modal").style.display = "none";
    console.log("Modal closed");
});

// Event listener for clicks outside the modal
window.onclick = (event) => {
    const modal = document.getElementById("audio-trimmer-modal");
    if (event.target === modal) {
        console.log("Clicked outside the modal");
        // Hide the modal
        modal.style.display = "none";
        console.log("Modal closed");
    }
};




    // Get the input element for project name
    const projectNameInput = document.getElementById("project-name");
    // Event listener for input event on project name input
    projectNameInput.addEventListener("input", () => {
        const projectName = projectNameInput.value.trim();
        // Update project name setting
        window.unifiedSequencerSettings.updateSetting("projectName", projectName);
        // If project name is empty, set default
        if (!projectName) {
            projectNameInput.value = "Default Project Name";
        }
    });


window.addEventListener('message', (event) => {
    console.log('Received message:', event);
    // WARNING: Setting allowedOrigins to '*' accepts messages from any origin.
    // This can be a security risk. Use with caution and ensure that your application
    // validates the content of the messages and acts upon them securely.
    const allowedOrigins = '*';

    // The check against allowedOrigins is redundant when accepting all origins,
    // but left here for demonstration. In practice, if using '*', you'd remove this check.
    if (allowedOrigins !== '*' && !allowedOrigins.includes(event.origin)) {
        console.error('Received message from unauthorized origin:', event.origin);
        return;
    }

    // Attempt to parse the message data
    let data;
    try {
        data = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;
    } catch (error) {
        console.error('Error parsing message data:', error);
        return;
    }

    // Handle commands such as "load" or "play" based on the parsed data
    if (data.command === 'load' && data.settings) {
        console.log('Loading settings:', data.settings);
        sequencerSettings.loadSettings(data.settings); // Correct usage
    }

    if (data.command === 'play') {
        console.log('Playing the loaded settings');
        if (!sequencerSettings.isPlaying) {
            // Assuming startScheduler and emitPlay are methods of sequencerSettings
            sequencerSettings.startScheduler();
            sequencerSettings.emitPlay();
            sequencerSettings.isPlaying = true;
        }
    }
});

//     // Adjusting the "New/Load" button event listener for direct load and play
// newLoadButton.addEventListener("click", async () => {
//     console.log("[Load Process] Load button clicked, loading 'BasedSong1.json'");

//     try {
//         const response = await fetch('BasedSong1.json'); // Adjust the path as needed
//         const json = await response.json();
//         console.log("[Load Process] Settings loaded:", json);

//         // Assuming window.unifiedSequencerSettings exists and is ready to use
//         window.unifiedSequencerSettings.loadSettings(json);
//         console.log("[Load Process] Settings applied to the sequencer");

//         // Process channel URLs for audio loading
//         if (json.channelURLs && Array.isArray(json.channelURLs)) {
//             await processChannelURLs(json.channelURLs);
//         }

//         // Resume AudioContext if needed
//         if (audioContext && audioContext.state === 'suspended') {
//             await audioContext.resume();
//             console.log("[Load Process] AudioContext resumed.");
//         }

//         // Start the scheduler for playback, assuming `startScheduler` is already defined and properly sets up playback.
//         // Ensure this function exists and is designed to start playback in your application context.
//         startScheduler(); // This directly initiates playback according to your sequencer's scheduling logic.

//         console.log("[Load Process] Playback started via startScheduler.");
//     } catch (error) {
//         console.error("[Load Process] Error loading or applying settings:", error);
//     }
// });
</script>


<script src="g2.js"></script>
<script src="c2.js"></script>
<script src="d2.js"></script>