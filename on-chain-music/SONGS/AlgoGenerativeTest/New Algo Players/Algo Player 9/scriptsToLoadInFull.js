// startPlaybackLoop
function startPlaybackLoop(){globalJsonData&&(bpm=globalJsonData.projectBPM)}async function initializePlayback(){await resumeAudioContext(),startPlaybackLoop(),startWorker()}async function stopPlayback(){Object.keys(activeSources).forEach((a=>{activeSources[a].forEach((({source:a,gainNode:e})=>{e.gain.cancelScheduledValues(audioCtx.currentTime),e.gain.setValueAtTime(e.gain.value,audioCtx.currentTime),e.gain.linearRampToValueAtTime(0,audioCtx.currentTime+fadeDuration),a.stop(audioCtx.currentTime+fadeDuration),a.disconnect(),e.disconnect()})),activeSources[a]=[]})),setTimeout((async()=>{await audioCtx.suspend(),resetPlaybackState()}),50)}


// audioProcessing.js
async function fetchAndProcessAudioData(e){await Promise.all(e.map(((e,t)=>processAudioUrl(e,t+1,audioCtx)))),createReversedBuffersForChannelsWithReverseSteps()}function getOrCreateGainNode(e){return gainNodes[e]||(gainNodes[e]=audioCtx.createGain(),gainNodes[e].connect(audioCtx.destination)),gainNodes[e]}async function processAudioUrl(e,t,r){try{const o=await fetch(e);if(!o.ok)throw new Error(`Failed to fetch from URL: ${e}, Status: ${o.status}`);const a=o.headers.get("Content-Type"),n=await fetchAndDecodeAudio(o,a,r);if(n){const e=`Channel ${t}`,r=getOrCreateGainNode(e),o=parseVolumeLevel(globalVolumeLevels[e])*globalVolumeMultiplier;r.gain.value=o,globalAudioBuffers.push({buffer:n,gainNode:r,channel:e})}else console.error(`Failed to decode audio for ${channelName}:`,e)}catch(e){console.error(`Error processing audio URL for ${channelName}:`,e)}}function setGlobalVolumeMultiplier(e){globalVolumeMultiplier=Math.max(0,e),globalAudioBuffers.forEach((({gainNode:e,channel:t})=>{const r=parseVolumeLevel(globalVolumeLevels[t]);e.gain.value=r*globalVolumeMultiplier}))}async function fetchAndDecodeAudio(e,t,r){if(/audio\/(wav|mpeg|mp4)/.test(t)||/video\/mp4/.test(t)){const t=await e.arrayBuffer();return r.decodeAudioData(t)}const o=await e.text();let a=null;if(/application\/json/.test(t)?a=JSON.parse(o).audioData:/text\/html/.test(t)&&(a=extractBase64FromHTML(o)),a){const e=base64ToArrayBuffer(a.split(",")[1]);return r.decodeAudioData(e)}if(/audio\//.test(t)){const t=await e.arrayBuffer();return r.decodeAudioData(t)}return null}function createReversedBuffersForChannelsWithReverseSteps(){const e=new Set;for(const t of Object.values(globalJsonData.projectSequences))for(const[r,o]of Object.entries(t))o.steps.some((e=>e.reverse))&&e.add(`Channel ${parseInt(r.slice(2))+1}`);globalAudioBuffers.forEach((({buffer:t,channel:r})=>{e.has(r)&&(globalReversedAudioBuffers[r]=createReversedBuffer(t))}))}function createReversedBuffer(e){const t=audioCtx.createBuffer(e.numberOfChannels,e.length,e.sampleRate);for(let r=0;r<e.numberOfChannels;r++){const o=e.getChannelData(r);t.getChannelData(r).set([...o].reverse())}return t}function base64ToArrayBuffer(e){try{const t=window.atob(e),r=t.length,o=new Uint8Array(r);for(let e=0;e<r;e++)o[e]=t.charCodeAt(e);return o.buffer}catch(e){return console.error("[base64ToArrayBuffer] Error converting base64 to ArrayBuffer:",e),null}}function extractBase64FromHTML(e){try{const t=new DOMParser,r=t.parseFromString(e,"text/html").querySelector("audio[data-audionalSampleName] source");if(r){const e=r.getAttribute("src");if(/^data:audio\/(wav|mp3|mp4);base64,/.test(e.toLowerCase()))return e;if(/audio\//.test(e.toLowerCase()))return e;console.error("[extractBase64FromHTML] Audio data does not start with expected base64 prefix.")}else console.error("[extractBase64FromHTML] Could not find the audio source element in the HTML content.")}catch(e){console.error("[extractBase64FromHTML] Error parsing HTML content:",e)}return null}


// playBuffer
function playBuffer(e,{startTrim:t,endTrim:a},i,n){t=Math.max(0,Math.min(t,1)),a=Math.max(t,Math.min(a,1));const u=t*e.duration,o=(a-t)*e.duration,r=audioCtx.createBufferSource();r.buffer=e;const c=globalPlaybackSpeeds[i]||1;r.playbackRate.value=c;const l=audioCtx.createGain(),s=parseVolumeLevel(globalVolumeLevels[i]||defaultVolume)*globalVolumeMultiplier,d=audioCtx.currentTime;l.gain.cancelScheduledValues(d),l.gain.setValueAtTime(0,d),l.gain.linearRampToValueAtTime(s,d+fadeDuration),r.connect(l),l.connect(audioCtx.destination),r.start(n,u,o/c),activeSources[i]||(activeSources[i]=[]),activeSources[i].push({source:r,gainNode:l}),r.onended=()=>{activeSources[i]=activeSources[i].filter((e=>e.source!==r))}}function calculateReversedTrimTimes(e){return{startTrim:1-e.endTrim,endTrim:1-e.startTrim}}function parseVolumeLevel(e){const t="number"==typeof e?e:parseFloat(e);return clampVolume(isNaN(t)?defaultVolume:t)}function clampVolume(e){return Math.max(0,Math.min(e,3))}async function resumeAudioContext(){await window.AudioContextManager.resume()}async function ensureAudioContextState(){await resumeAudioContext(),console.log("AudioContext state:",audioCtx.state)}function resetPlaybackState(){currentSequence=0,currentStep=0,isReversePlay=!1,nextNoteTime=0,resetVisualState()}function resetAllStates(){resetPlaybackState(),resetVisualState()}function resetVisualState(){"undefined"!=typeof cci2&&"undefined"!=typeof initialCCI2&&(cci2=initialCCI2),isChannel11Active=!1,isPlaybackActive=!1,activeChannelIndex=null,activeArrayIndex={},renderingState={},"function"==typeof immediateVisualUpdate&&immediateVisualUpdate()}


// visualiserMessaging.js
const fadeDuration=.01;function notifyVisualizer(e,n){AudionalPlayerMessages.postMessage({action:"activeStep",channelIndex:e,step:n}),document.dispatchEvent(new CustomEvent("internalAudioPlayback",{detail:{action:"activeStep",channelIndex:e,step:n}}))}document.addEventListener("click",(async()=>{"function"==typeof window.ensureAudioContextState?(await window.ensureAudioContextState(),await togglePlayback(),document.dispatchEvent(new CustomEvent("playbackStarted"))):console.error("[fileAndAudioHandling.js] ensureAudioContextState is not defined or not a function")}));const defaultVolume=1;async function togglePlayback(){isToggleInProgress,isToggleInProgress=!0;try{isPlaying?(await stopPlayback(),isPlaying=!1):(await initializePlayback(),isPlaying=!0)}catch(e){console.error("Error during playback toggle:",e)}finally{isToggleInProgress=!1}}function cleanUpWorker(){clearInterval(intervalID),audioWorker?.terminate(),audioCtx.suspend().then((()=>console.log("AudioContext suspended successfully.")))}window.addEventListener("beforeunload",cleanUpWorker);


//dispatchSequenceEvents
function dispatchSequenceEvent(e,t){const n=new CustomEvent(e,{detail:t});document.dispatchEvent(n)}function playSequenceStep(e){if(!isReadyToPlay||!Object.keys(preprocessedSequences).length)return console.error("Sequence data is not ready or empty.");const t=Object.keys(preprocessedSequences);currentSequence%=t.length;const n=preprocessedSequences[t[currentSequence]];n&&Object.keys(n).length?(playSteps(n.normalSteps,e),playSteps(n.reverseSteps,e,!0),incrementStepAndSequence(t.length)):incrementStepAndSequence(t.length)}function playSteps(e,t,n=!1){if(!e||"object"!=typeof e)return console.error("[playSteps] Invalid steps data:",e);for(const[r,c]of Object.entries(e))if(Array.isArray(c)){const e=c.find((e=>e.step===currentStep));e&&playChannelStep(r,e,t,n)}else console.error(`[playSteps] Expected steps to be an array for channel "${r}", but got:`,c)}function playChannelStep(e,t,n,r){const c=globalAudioBuffers.find((t=>t.channel===e)),o=globalTrimTimes[e];if(c?.buffer&&o){const s=r?globalReversedAudioBuffers[e]:c.buffer,u=r?calculateReversedTrimTimes(o):o;playBuffer(s,u,e,n),notifyVisualizer(parseInt(e.slice(8))-1,t.step)}else console.error(`No audio buffer or trim times found for ${e}`)}function scheduleNotes(){const e=audioCtx.currentTime;for(nextNoteTime=Math.max(nextNoteTime,e);nextNoteTime<e+.1;){const e=nextNoteTime;playSequenceStep(e),audioCtx.currentTime>e&&console.warn(`[scheduleNotes] Note scheduled for ${e.toFixed(3)} missed at ${audioCtx.currentTime.toFixed(3)}.`),nextNoteTime+=getStepDuration()}}function incrementStepAndSequence(e){currentStep=(currentStep+1)%64,0===currentStep&&(currentSequence=(currentSequence+1)%e),dispatchSequenceEvent("sequenceUpdated",{currentSequence:currentSequence,currentStep:currentStep})}document.addEventListener("sequenceUpdated",(e=>{const{currentSequence:t,currentStep:n}=e.detail}));


// initialiseWorker
function initializeWorker(){if(!window.Worker)return console.error("Web Workers are not supported in your browser.");const e=new Blob(["\n        let stepDuration;\n        let timerID;\n\n        self.onmessage = ({ data }) => {\n            if (data.action === 'start') {\n                stepDuration = data.stepDuration * 500; // Convert to milliseconds\n                startScheduling();\n            } else if (data.action === 'stop') {\n                clearInterval(timerID);\n            }\n        };\n\n        function startScheduling() {\n            clearInterval(timerID);\n            timerID = setInterval(() => postMessage({ action: 'scheduleNotes' }), stepDuration);\n        }\n    "],{type:"application/javascript"}),t=URL.createObjectURL(e);audioWorker=new Worker(t),audioWorker.onmessage=({data:e})=>{"scheduleNotes"===e.action&&scheduleNotes()},window.addEventListener("beforeunload",cleanUpWorker)}function startWorker(){audioWorker?.postMessage({action:"start",stepDuration:getStepDuration()})}function stopWorker(){audioWorker?.postMessage({action:"stop"})}function getStepDuration(){return 60/(globalJsonData?.projectBPM||120)/4}

