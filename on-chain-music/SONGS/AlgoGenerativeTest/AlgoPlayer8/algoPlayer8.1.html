<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>? ? ? ? ? ? ?</title>
    <script>
        window.seed = 169;  // Default seed
    
    </script>
 <style>
 body {margin: 0;padding: 0;width: 100%;height: 100%;overflow: hidden;display: flex;justify-content: center;align-items: center;}#canvas-container {width: 50vmin;height: 50vmin;display: flex;justify-content: center;align-items: center;background-color: white;position: relative;}body, html {height: 100%;margin: 0;display: flex;align-items: center;justify-content: center;background-color: #000000;position: relative;transform: scale(0.7);}.text-element, .play-text {position: fixed;top: 50%;left: 50%;transform: translate(-50%, -50%);text-align: center;z-index: 10001;opacity: 1;transition: opacity 5s ease-in-out;}.play-text {font-size: 125px;font-style: bold;font-weight: 700;color: #ff00bf;z-index: 10001;opacity: 1;transition: opacity 30s ease-in-out;}.sqyzy {font-family: Arial, bold, sans-serif;color: #000000;}.freedom {font-size: 125px;font-weight: 700;font-style: bold;}.melophonic {font-family: "Trebuchet MS", bold, sans-serif;font-size: 65px;color: #000;}.sqyzy {font-size: 96px;font-weight: 500;}.fade-overlay {position: fixed;top: 0;left: 0;width: 100%;height: 100%;background: #000;z-index: 10000;opacity: 1;transition: opacity 10s ease-in-out;}

/* New Styles to Handle Canvas */
canvas#cv {
    position: absolute; /* Ensure it's not affecting the flow of the document */
    top: 50%; /* Center vertically */
    left: 50%; /* Center horizontally */
    transform: translate(-50%, -50%); /* Translate it back to the center */
    z-index: 9999; /* Place it below the text elements but above other content */
    pointer-events: none; /* Prevent the canvas from intercepting any pointer events */
}

</style>
</head>
<body>

<userDefinedData>
<script>
        function createTextElement(text, className) {
        try {
            const element = document.createElement("div");
            if (text) element.textContent = text;
            if (className) element.classList.add(className);
            document.body.appendChild(element);
            return element;
        } catch (error) {
            console.error(`Error creating element:`, error);
        }
    }
    // IFE #1
    (function IIFE1() {
        console.log(`[${new Date().toISOString()}] First IIFE [init] starting with seed:`, window.seed);

        function init() {
            console.log(`[${new Date().toISOString()}] init function called.`);
            try {

                const songDataUrls = [
                    "/content/5527d0cc95ce5ce6eedf4e275234da8b1fe087512d0db618b6de1aaad437c96bi0", // TRUTH
                    "/content/b22f1c85371b58a9cdac19b2baa50b1f9025a28d44cdfaad539d0527aa7d894ei0", // On-Chain in the Membrane
                    "/content/8aec0a99a5617b9da98a5b63a11a5143f0cac3cfa662d9515c2285de03ef95d4i0", // CHEESE
                    "/content/6d288c0c82653001bb32497889dd1486e8afec9b0671a95fa9e10f99c20737bbi0", // KORA
                    "/content/07ff7bdc47e5272a3ff55cc46d2b189d510562a057a2c24112f3d0376950484di0", // CHOPPIN' IT UP
                    // "/content/119a3ccd1dfd7e987cca139f86d16717d845a22dd6afc59ad492527b95ae9a91i0", // MLK I HAVE A DREAM
                    "/content/db9131cfe8e933e8e639f007dcd2b582a80bfd2be42b0eafa4d2e206332d6785i0", // ModernProgress
                    "/content/fb0d2abcd1fa5bf2622579f0990435b48d41291f71626fc2e36a93e6ea6b3b85i0", // HUMANITY
                    "/content/3359ce42359274ddbd2184d9f75a38b7e59b1d5f24512959e29c377fc8ca604ai0", // MintyFresh Vibes
                    "/content/633100d631767ddb9a309f5a2a66f5a66d5abd839f3b1c55642690d484189971i0", // ON DAY ONE
                ];
                
                if (songDataUrls && songDataUrls.length > 0) {
                    console.log(`[${new Date().toISOString()}] songDataUrls array is defined and has ${songDataUrls.length} items. Proceeding with processing...`);
                    processSerializedData(songDataUrls);
                    console.log(`[${new Date().toISOString()}] processSerializedData completed successfully.`);
                } else {
                    console.warn(`[${new Date().toISOString()}] songDataUrls array is either undefined or empty.`);
                }
            } catch (error) {
                console.error(`[${new Date().toISOString()}] Error in init function:`, error);
            }
        }

        window.init = init;
        window.addEventListener('load', function() {
            console.log(`[${new Date().toISOString()}] Window load event triggered.`);
            init();
            console.log(`[${new Date().toISOString()}] init function execution completed.`);
        });

        console.log(`[${new Date().toISOString()}] First IIFE [init] completed.`);
    })();

(function InteractionModule() {
    
    function displayText(texts) {
        texts.forEach(({ text, className, fadeIn, fadeOut }) => {
            const textElement = createTextElement(text, className);
            setTimeout(() => {
                textElement.style.opacity = "1";
            }, fadeIn);
            setTimeout(() => {
                textElement.style.opacity = "1";
            }, fadeOut);
        });
    }

    window.onload = function() {
        try {
            initialFadeIn();
            document.title = "? ? ? ? ? ? ?";
            displayPlayText();
        } catch (error) {
            console.error(`Error during window.onload execution:`, error);
        }
    };

    // Sample usage of displayText
    const texts = [
        { text: "?\u2008?\u2008?\u2008?\u2008?", className: "freedom", fadeIn: 0, fadeOut: 15740 },
        { text: "?elo?honi?", className: "melophonic", fadeIn: 15740, fadeOut: 41480 },
        { text: "?Q?Z?", className: "sqyzy", fadeIn: 41480, fadeOut: 57800 }
    ];

    displayText(texts);
})();

</script>
</userDefinedData>


<defineScriptsToLoad>
<script>
       // Array of scripts to load
       window.scriptsToLoad = [
            "/content/61895db1f0d62d24cea96570e66b92435a8a4979e3d3fef8041680ed2afeddc8i0", // audioContextManager.js
            "/content/1b036f9d60a04f0612af8c53753273f66339e69d7843138007eb3573703b1218i0", // jsonLoader.js
            "/content/150e020d5e6ea8b53b7b3d2160f25f65c2e550d413f9c53d9e1cfb101d6914f2i0", // audioProcessing.js
            "/content/935828577e4762caaf32b76a0f74cb4f37bdcdbdae1d27a7c93d000d5cfe9d28i0", // playBuffer
            "/content/bab2b37e0abcce41d784d65d94a5c3c266228c2d8bd3ecdee4fba7986f5a042ei0", // visualiserMessaging
            "/content/1a5cafb61e4a320434fc4087e203d2a5f695ba9112635b960fc9d7dcb961d9fci0", // startPlaybackLoop
            "/content/a3d8a40fcde6935f16b49ad7c9e9aa185f01d1618f4e35828415f6cc27377a47i0", // dispatchSequenceEvents
            "/content/17c6cb4f92d47043da52ce8334c41961c588b7955488e56f08264840ef63a4eei0", // initialiseWorker
            "/content/4915e144695ab04171092a45e2d49cfa7b5e92c9a35ce612e7b749457acc92ddi0", // titleDisplays_2.js
            "/content/3ab9dda407f9c7f62b46401e2664bc1496247c8950620a11a36a8601267cb42fi0", // colourPalette.js
            "/content/4a6164e05aee1d4ed77585bc85e4d4530801ef71e1c277c868ce374c4a7b9902i0", // colourSettingsaMaster
            "/content/0505ae5cebbe9513648fc8e4ecee22d9969764f3cdac9cd6ec33be083c77ae96i0", // colourSettingsLevel0.js
            "/content/87bb49f5617a241e29512850176e53169c3da4a76444d5d8fcd6c1e41489a4b3i0", // colourSettingsLevel1 
            "/content/cea34b6ad754f3a4e992976125bbd1dd59213aab3de03c9fe2eb10ddbe387f76i0", // colourSettingsLevel2
            "/content/bcee9a2e880510772f0129c735a4ecea5bb45277f3b99ff640c1bd393dddd6dfi0", // colourSettingsLevel3
            "/content/90d910fe4088c53a16eb227ec2fe59802091dc4ea51564b2665090403c34f59ci0", // colourSettingsLevel4
            "/content/916fd1731cdecf82706a290d03448c6dc505c01d6ec44bbca20281a19723d617i0", // colourSettingsLevel5
            "/content/6a5e5c8b42793dd35512dfddd81dbbe211f052ac79839dd54b53461f5783a390i0", // colourSettingsLevel6
            "/content/c0ee69121238f6438be8398038301cf5b1d876cce30a0d45a3a5e0b927826940i0", // colourSettingsLevel7
            "/content/6f1def70a3290c50793773a8b1712c9a1b0561b3674ee50a06c13bc4e492f459i0", // colourSettingsLevel8
            "/content/c7c92a81d5279950be7d0bd3e755ad620551bc65e6e514d6f7c29b4c24465d0ai0", // initVisualiser.js
            "/content/99ecc0668e27f03cf202f9ebc49d0332ac8f594bc9b5483969108b83723a0e9di0", // visualiserLogging.js
            "/content/305829e076d38130be65851c79241929983f16d679822015ff237029f67d5d9ei0", // visualiserMessageHandling_minified.js
            "/content/0d8309856ec04e8ab5bd6aa4689429102378fb45368ad0e2787f0dfc72c66152i0", // visualiserWorkers.js
            "/content/287c837ecffc5b80d8e3c92c22b6dbf0447a3d916b95ee314c66909f6f2b2f3ci0", // visualiserGeometry.js
            "/content/214457a4f832847565746ecb0b9460ec7dc8ad93549a00a69f18b3d492c0e005i0" // visualiserDrawingColours.js
        ];
</script>
</defineScriptsToLoad>


<customElements>
<script>
// CustomElementsModule.js
(function CustomElementsModule() {
    function loadScript(src) {
        try {
            const scriptElement = document.createElement("script");
            scriptElement.src = src;
            document.body.appendChild(scriptElement);
        } catch (error) {
            console.error(`Error loading script:`, error);
        }
    }

    // function createTextElement(text, className) {
    //     try {
    //         const element = document.createElement("div");
    //         if (text) element.textContent = text;
    //         if (className) element.classList.add(className);
    //         document.body.appendChild(element);
    //         return element;
    //     } catch (error) {
    //         console.error(`Error creating element:`, error);
    //     }
    // }

    function fadeOutElementById(id, delay = 100) {
        try {
            const element = document.getElementById(id);
            if (element) {
                setTimeout(() => {
                    element.style.opacity = "0";
                }, delay);
            }
        } catch (error) {
            console.error(`Error in fadeOutElementById:`, error);
        }
    }

    function displayTextElements(texts) {
        texts.forEach(({ text, className, fadeIn, fadeOut }) => {
            const textElement = createTextElement(text, className);
            setTimeout(() => {
                textElement.style.opacity = "1";
            }, fadeIn);
            setTimeout(() => {
                textElement.style.opacity = "0";
            }, fadeOut);
        });
    }

    function displayPlayText() {
        try {
            const playTextElement = createTextElement("?\u2008?\u2008?\u2008?\u2008?", "play-text");
            setTimeout(() => {
                playTextElement.style.opacity = "0";
            }, 100);
        } catch (error) {
            console.error(`Error in displayPlayText:`, error);
        }
    }

    // Expose functions globally
    window.loadScript = loadScript;
    window.createTextElement = createTextElement;
    window.fadeOutElementById = fadeOutElementById;
    window.displayTextElements = displayTextElements;
    window.displayPlayText = displayPlayText;

    // Load the PFP script
    loadScript("/content/97c042112c29d9a9ca1da99890542befdbffaec6ff17798897c187a617a62f79i0");

    console.log(`[${new Date().toISOString()}] CustomElementsModule initialized.`);
})();
</script>
</customElements>

<processingUtilities>
    <script>
    // processingUtilities.js
    (function ProcessingUtilities() {
        function hashString(str) {
            console.log(`[${new Date().toISOString()}] hashString function called with input:`, str);
            let rotationCount = parseInt(str.split("i")[1]);
            console.log(`[${new Date().toISOString()}] Rotation count parsed:`, rotationCount);
            
            let characters = str.split("");
            for (let i = 0; i < rotationCount; i++) {
                let char = characters.shift();
                characters.push(char);
            }
            str = characters.join("");
            console.log(`[${new Date().toISOString()}] String after rotation:`, str);
    
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = (31 * hash + str.charCodeAt(i)) % Number.MAX_SAFE_INTEGER;
            }
            const finalHash = hash % 1400000000;
            console.log(`[${new Date().toISOString()}] Final hash calculated:`, finalHash);
            return finalHash;
        }
    
        const seedValue = hashString("4482324585393f1523e8c28a02605c0b1c95d2779510921da0f131a5e6da5843i0");
        console.log(`[${new Date().toISOString()}] Hash string returned seed value:`, seedValue);
    
        function seededRandom(localSeed) {
            const x = Math.sin(localSeed) * 10000;
            return x - Math.floor(x);
        }
    
        function setPlaybackStatus(status) {
            window.playbackStarted = status;
        }
    
        function initializePlayback() {
            if (window.playbackStarted === undefined) {
                window.playbackStarted = false;
            }
    
            document.addEventListener("playbackStarted", () => {
                window.psTime = Date.now();
                setPlaybackStatus(true);
                if (typeof displayPlayText === 'function') {
                    displayPlayText();  // Assuming displayPlayText is globally available
                }
            });
    
            document.addEventListener("playbackStopped", () => {
                setPlaybackStatus(false);
            });
        }
    
        function enforceDocumentTitle() {
            document.title = "? ? ? ? ? ? ?";
            const titleObserver = new MutationObserver(() => {
                if (document.title !== "? ? ? ? ? ? ?") {
                    document.title = "? ? ? ? ? ? ?";
                }
            });
            titleObserver.observe(document.querySelector("title"), { childList: true, subtree: true });
        }
    
        const keyMap = {
            0: "projectName", 1: "artistName", 2: "projectBPM", 3: "currentSequence", 
            4: "channelURLs", 5: "channelVolume", 6: "channelPlaybackSpeed", 
            7: "trimSettings", 8: "projectChannelNames", 9: "startSliderValue", 
            10: "endSliderValue", 11: "totalSampleDuration", 12: "start", 
            13: "end", 14: "projectSequences", 15: "steps"
        };
    
        const reverseKeyMap = Object.fromEntries(Object.entries(keyMap).map(([e, r]) => [r, +e]));
        const channelMap = Array.from({ length: 26 }, (_, r) => String.fromCharCode(65 + r));
        const reverseChannelMap = Object.fromEntries(channelMap.map((e, r) => [e, r]));
    
        function decompressSteps(e) {
            return e.flatMap(e => {
                if (typeof e === "number") return e;
                if (typeof e === "object" && "r" in e) {
                    const [r, t] = e.r;
                    return Array.from({ length: t - r + 1 }, (e, t) => r + t);
                }
                return typeof e === "string" && e.endsWith("r") ? { index: parseInt(e.slice(0, -1), 10), reverse: true } : void 0;
            });
        }
    
        function deserialize(e) {
            const r = e => Array.isArray(e) ? e.map(e => typeof e === "object" ? r(e) : e) : typeof e === "object" && e !== null ? Object.entries(e).reduce((e, [t, n]) => {
                const a = keyMap[t] ?? t;
                return e[a] = a === "projectSequences" ? Object.entries(n).reduce((e, [r, t]) => (e[r.replace("s", "Sequence")] = Object.entries(t).reduce((e, [r, t]) => {
                    var n;
                    return e[`ch${reverseChannelMap[r]}`] = { steps: (n = t[reverseKeyMap.steps] || [], n.flatMap(e => {
                        if (typeof e === "number") return e;
                        if (typeof e === "object" && "r" in e) {
                            const [r, t] = e.r;
                            return Array.from({ length: t - r + 1 }, (e, t) => r + t);
                        }
                        return typeof e === "string" && e.endsWith("r") ? { index: parseInt(e.slice(0, -1), 10), reverse: true } : void 0;
                    })) }, e;
                }, {}), e), {}) : r(n), e;
            }, {}) : e;
            return r(e);
        }
    
        // Expose functions globally for use in the next script
        window.hashString = hashString;
        window.seededRandom = seededRandom;
        window.setPlaybackStatus = setPlaybackStatus;
        window.initializePlayback = initializePlayback;
        window.enforceDocumentTitle = enforceDocumentTitle;
        window.decompressSteps = decompressSteps;
        window.deserialize = deserialize;
        window.keyMap = keyMap;
        window.reverseKeyMap = reverseKeyMap;
        window.channelMap = channelMap;
        window.reverseChannelMap = reverseChannelMap;
    
        initializePlayback();
    
        window.onload = function() {
            console.log(`[${new Date().toISOString()}] window.onload triggered.`);
            enforceDocumentTitle();
            if (typeof displayPlayText === 'function') {
                displayPlayText();  // Assuming displayPlayText is globally available
            }
            console.log(`[${new Date().toISOString()}] onload functions executed successfully.`);
        };
    
        console.log(`[${new Date().toISOString()}] ProcessingUtilities initialized.`);
    })();
    </script>
</processingUtilities>



<dataProcessingCore>
    <script>
    // dataProcessingCore.js
    (function DataProcessingCore() {
        async function loadPako() {
            try {
                const t = await fetch("/content/2109694f44c973892fb8152cf5c68607fb19288c045af1abc1716c1c3b4d69e6i0");
                const o = await t.text();
                const e = document.createElement("div");
                e.innerHTML = o;
                const n = e.querySelectorAll("script");
                const c = Array.from(n).find(t => t.textContent.includes("pako"));
                if (!c) {
                    throw new Error("Pako library not found in the HTML content.");
                }
                const r = document.createElement("script");
                r.textContent = c.textContent;
                document.head.appendChild(r);
            } catch (t) {
                console.error(`Error occurred during Pako loading:`, t);
            }
        }
    
        async function fetchAndDeserialize(url) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Network response was not ok for URL: ${url}`);
                }
                const arrayBuffer = await response.arrayBuffer();
                const inflated = pako.inflate(new Uint8Array(arrayBuffer));
                const text = new TextDecoder("utf-8").decode(inflated);
                const jsonData = JSON.parse(text);
                return deserialize(jsonData);
            } catch (error) {
                console.error(`Error in fetchAndDeserialize:`, error);
                throw error;
            }
        }
    
        function shuffleArray(array, localSeed) {
            let currentSeed = localSeed;
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(seededRandom(currentSeed) * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
                currentSeed += 1;
            }
            return array;
        }
    
        const availableBPMs = [80, 100, 120, 140, 160, 180, 240];
    
        function selectBPM(availableBPMs, seed) {
            const seededIndex = Math.floor(seededRandom(seed) * availableBPMs.length);
            return availableBPMs[seededIndex];
        }
    
        async function processSerializedData(urls) {
            try {
                await loadPako();
    
                const data = await Promise.all(urls.map(async (url) => {
                    try {
                        const result = await fetchAndDeserialize(url);
                        if (!result || !result.projectSequences) {
                            throw new Error(`Invalid data at URL ${url}`);
                        }
                        return result;
                    } catch (error) {
                        console.error(`Error processing URL:`, error);
                        return undefined;
                    }
                }));
    
                const validData = data.filter(dataset => dataset !== undefined);
    
                const baseBPM = selectBPM(availableBPMs, window.seed);
    
                const useHarmonicAdjustment = false;
    
                validData.forEach((dataset) => {
                    const currentBPM = dataset.projectBPM;
                    const bpmRatio = baseBPM / currentBPM;
    
                    dataset.channelPlaybackSpeed = dataset.channelPlaybackSpeed.map(speed => {
                        return useHarmonicAdjustment && Math.abs(baseBPM - currentBPM) >= baseBPM / 2
                            ? speed
                            : speed * bpmRatio;
                    });
                });
    
                const allChannels = [];
                validData.forEach((dataset, datasetIndex) => {
                    for (let index = 0; index < dataset.channelURLs.length; index++) {
                        allChannels.push({
                            url: dataset.channelURLs[index],
                            volume: dataset.channelVolume[index],
                            speed: dataset.channelPlaybackSpeed[index],
                            trim: dataset.trimSettings[index],
                            source: `data${datasetIndex + 1}`,
                            index
                        });
                    }
                });
    
                const shuffledChannels = shuffleArray(allChannels, window.seed);
                const selectedChannels = shuffledChannels.slice(0, 24);
    
                const combinedData = {
                    ...validData[0],
                    projectBPM: baseBPM,
                    channelURLs: selectedChannels.map(ch => ch.url),
                    channelVolume: selectedChannels.map(ch => ch.volume),
                    channelPlaybackSpeed: selectedChannels.map(ch => ch.speed),
                    trimSettings: selectedChannels.map(ch => ch.trim),
                    projectSequences: {}
                };
    
                const projectSequencesSources = validData.reduce((acc, dataset, i) => {
                    acc[`data${i + 1}`] = dataset;
                    return acc;
                }, {});
    
                for (const seq in validData[0].projectSequences) {
                    combinedData.projectSequences[seq] = {};
    
                    selectedChannels.forEach((ch, i) => {
                        const chKey = `ch${i}`;
                        const sourceSeq = projectSequencesSources[ch.source]?.projectSequences[seq];
    
                        if (sourceSeq && sourceSeq[`ch${ch.index}`]) {
                            combinedData.projectSequences[seq][chKey] = sourceSeq[`ch${ch.index}`];
                        } else {
                            combinedData.projectSequences[seq][chKey] = { steps: [] };
                        }
                    });
                }
    
                const blob = new Blob([JSON.stringify(combinedData)], { type: "application/json" });
                window.jsonDataUrl = URL.createObjectURL(blob);
    
                // Signal that processing is done
                document.dispatchEvent(new CustomEvent("dataProcessingComplete"));
                console.log(`[${new Date().toISOString()}] [debugScriptloading] Data processing complete.`);
    
            } catch (e) {
                console.error(`Error processing data in processSerializedData:`, e);
            }
        }
    
        // Expose functions globally for the next script to use
        window.loadPako = loadPako;
        window.fetchAndDeserialize = fetchAndDeserialize;
        window.shuffleArray = shuffleArray;
        window.selectBPM = selectBPM;
        window.processSerializedData = processSerializedData;
    
        console.log(`[${new Date().toISOString()}] DataProcessingCore initialized.`);
    })();
    </script>
</dataProcessingCore>

<scriptLoader>
    <script>
    // scriptLoader.js
    (function ScriptLoader() {
        // Create and append canvas element
        const canvas = document.createElement("canvas");
        canvas.id = "cv";
        document.body.appendChild(canvas);
        document.body.style.cssText = `
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
        `;

        // Function to load scripts sequentially
        function loadScriptsSequentially(n, e = 0, t) {
            if (e < n.length) {
                const i = document.createElement("script");
                i.src = n[e];
                i.onload = () => loadScriptsSequentially(n, e + 1, t);
                document.head.appendChild(i);
            } else if (typeof t === "function") {
                t();
            }
        }

        // Function to initialize the app
        function initializeApp() {
            window.cci2 = 0;
            window.initialCCI2 = 0;
            resetAllStates();
            loadJsonFromUrl(window.jsonDataUrl);
            initializeWorker();
        }

     

        // Function to wait for jsonDataUrl to be defined
        function waitForJsonDataUrl(callback) {
            if (window.jsonDataUrl) {
                callback();
            } else {
                console.warn('jsonDataUrl is not defined yet, waiting...');
                setTimeout(() => waitForJsonDataUrl(callback), 100);  // Retry after 100ms
            }
        }

        // Start the process once jsonDataUrl is defined
        waitForJsonDataUrl(() => {
            console.log('Fetching from URL:', window.jsonDataUrl);
            fetch(window.jsonDataUrl)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(settings => {
                    window.settings = settings;
                    console.log("Settings loaded:", settings);
                    loadScriptsSequentially(window.scriptsToLoad, 0, async () => {
                        await ensureAudioContextState();
                        if (document.readyState === "loading") {
                            document.addEventListener("DOMContentLoaded", initializeApp);
                        } else {
                            initializeApp();
                        }
                    });
                })
                .catch(error => console.error("Error loading settings:", error));
        });
    
        console.log(`[${new Date().toISOString()}] [debugScriptloading] ScriptLoader initialized.`);
    })();
    </script>
</scriptLoader>


    
            
</body>
</html>