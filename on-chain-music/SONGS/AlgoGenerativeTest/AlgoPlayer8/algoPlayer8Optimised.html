    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
        <title>? ? ? ? ? ? ?</title>
        <script>
            window.seed = 324;  // Default seed
        
        </script>
    <style>
    body {margin: 0;padding: 0;width: 100%;height: 100%;overflow: hidden;display: flex;justify-content: center;align-items: center;}#canvas-container {width: 50vmin;height: 50vmin;display: flex;justify-content: center;align-items: center;background-color: white;position: relative;}body, html {height: 100%;margin: 0;display: flex;align-items: center;justify-content: center;background-color: #000000;position: relative;transform: scale(0.7);}.text-element, .play-text {position: fixed;top: 50%;left: 50%;transform: translate(-50%, -50%);text-align: center;z-index: 10001;opacity: 1;transition: opacity 5s ease-in-out;}.play-text {font-size: 125px;font-style: bold;font-weight: 700;color: #ff00bf;z-index: 10001;opacity: 1;transition: opacity 30s ease-in-out;}.sqyzy {font-family: Arial, bold, sans-serif;color: #000000;}.freedom {font-size: 125px;font-weight: 700;font-style: bold;}.melophonic {font-family: "Trebuchet MS", bold, sans-serif;font-size: 65px;color: #000;}.sqyzy {font-size: 96px;font-weight: 500;}.fade-overlay {position: fixed;top: 0;left: 0;width: 100%;height: 100%;background: #000;z-index: 10000;opacity: 1;transition: opacity 10s ease-in-out;}
    </style>
    </head>
    <body>

    <userDefinedData>
    <script>
        
        // IFE #1
        (function IIFE1() {
            console.log(`[${new Date().toISOString()}] First IIFE [init] starting with seed:`, window.seed);

            function init() {
                console.log(`[${new Date().toISOString()}] init function called.`);
                try {

                    const songDataUrls = [
                        "/content/5527d0cc95ce5ce6eedf4e275234da8b1fe087512d0db618b6de1aaad437c96bi0", // TRUTH
                        "/content/b22f1c85371b58a9cdac19b2baa50b1f9025a28d44cdfaad539d0527aa7d894ei0", // On-Chain in the Membrane
                        "/content/8aec0a99a5617b9da98a5b63a11a5143f0cac3cfa662d9515c2285de03ef95d4i0", // CHEESE
                        "/content/6d288c0c82653001bb32497889dd1486e8afec9b0671a95fa9e10f99c20737bbi0", // KORA
                        "/content/07ff7bdc47e5272a3ff55cc46d2b189d510562a057a2c24112f3d0376950484di0", // CHOPPIN' IT UP
                        // "/content/119a3ccd1dfd7e987cca139f86d16717d845a22dd6afc59ad492527b95ae9a91i0", // MLK I HAVE A DREAM
                        "/content/db9131cfe8e933e8e639f007dcd2b582a80bfd2be42b0eafa4d2e206332d6785i0", // ModernProgress
                        "/content/fb0d2abcd1fa5bf2622579f0990435b48d41291f71626fc2e36a93e6ea6b3b85i0", // HUMANITY
                        "/content/3359ce42359274ddbd2184d9f75a38b7e59b1d5f24512959e29c377fc8ca604ai0", // MintyFresh Vibes
                        "/content/633100d631767ddb9a309f5a2a66f5a66d5abd839f3b1c55642690d484189971i0", // ON DAY ONE
                    ];
                    
                    if (songDataUrls && songDataUrls.length > 0) {
                        console.log(`[${new Date().toISOString()}] songDataUrls array is defined and has ${songDataUrls.length} items. Proceeding with processing...`);
                        processSerializedData(songDataUrls);
                        console.log(`[${new Date().toISOString()}] processSerializedData completed successfully.`);
                    } else {
                        console.warn(`[${new Date().toISOString()}] songDataUrls array is either undefined or empty.`);
                    }
                } catch (error) {
                    console.error(`[${new Date().toISOString()}] Error in init function:`, error);
                }
            }

            window.init = init;
            window.addEventListener('load', function() {
                console.log(`[${new Date().toISOString()}] Window load event triggered.`);
                init();
                console.log(`[${new Date().toISOString()}] init function execution completed.`);
            });

            console.log(`[${new Date().toISOString()}] First IIFE [init] completed.`);
        })();

    (function InteractionModule() {
        
        function displayText(texts) {
            texts.forEach(({ text, className, fadeIn, fadeOut }) => {
                const textElement = createTextElement(text, className);
                setTimeout(() => {
                    textElement.style.opacity = "1";
                }, fadeIn);
                setTimeout(() => {
                    textElement.style.opacity = "1";
                }, fadeOut);
            });
        }

        window.onload = function() {
            try {
                initialFadeIn();
                document.title = "? ? ? ? ? ? ?";
                displayPlayText();
            } catch (error) {
                console.error(`Error during window.onload execution:`, error);
            }
        };

        // Sample usage of displayText
        const texts = [
            { text: "?\u2008?\u2008?\u2008?\u2008?", className: "freedom", fadeIn: 0, fadeOut: 15740 },
            { text: "?elo?honi?", className: "melophonic", fadeIn: 15740, fadeOut: 41480 },
            { text: "?Q?Z?", className: "sqyzy", fadeIn: 41480, fadeOut: 57800 }
        ];

        displayText(texts);
    })();

    </script>
    </userDefinedData>

    <customElements>
    <script>
    // CustomElementsModule.js
    (function CustomElementsModule() {
        function loadScript(src) {
            try {
                const scriptElement = document.createElement("script");
                scriptElement.src = src;
                document.body.appendChild(scriptElement);
            } catch (error) {
                console.error(`Error loading script:`, error);
            }
        }

        function createTextElement(text, className) {
            try {
                const element = document.createElement("div");
                if (text) element.textContent = text;
                if (className) element.classList.add(className);
                document.body.appendChild(element);
                return element;
            } catch (error) {
                console.error(`Error creating element:`, error);
            }
        }

        function fadeOutElementById(id, delay = 100) {
            try {
                const element = document.getElementById(id);
                if (element) {
                    setTimeout(() => {
                        element.style.opacity = "0";
                    }, delay);
                }
            } catch (error) {
                console.error(`Error in fadeOutElementById:`, error);
            }
        }

        function displayTextElements(texts) {
            texts.forEach(({ text, className, fadeIn, fadeOut }) => {
                const textElement = createTextElement(text, className);
                setTimeout(() => {
                    textElement.style.opacity = "1";
                }, fadeIn);
                setTimeout(() => {
                    textElement.style.opacity = "0";
                }, fadeOut);
            });
        }

        function displayPlayText() {
            try {
                const playTextElement = createTextElement("?\u2008?\u2008?\u2008?\u2008?", "play-text");
                setTimeout(() => {
                    playTextElement.style.opacity = "0";
                }, 100);
            } catch (error) {
                console.error(`Error in displayPlayText:`, error);
            }
        }

        // Expose functions globally
        window.loadScript = loadScript;
        window.createTextElement = createTextElement;
        window.fadeOutElementById = fadeOutElementById;
        window.displayTextElements = displayTextElements;
        window.displayPlayText = displayPlayText;

        // Load the PFP script
        loadScript("/content/97c042112c29d9a9ca1da99890542befdbffaec6ff17798897c187a617a62f79i0");

        console.log(`[${new Date().toISOString()}] CustomElementsModule initialized.`);
    })();
    </script>
    </customElements>

    <processingModule> 
    <script>
    // ProcessingModule.js
    (function ProcessingModule() {
        function hashString(str) {
            console.log(`[${new Date().toISOString()}] hashString function called with input:`, str);
            let rotationCount = parseInt(str.split("i")[1]);
            console.log(`[${new Date().toISOString()}] Rotation count parsed:`, rotationCount);
            
            let characters = str.split("");
            for (let i = 0; i < rotationCount; i++) {
                let char = characters.shift();
                characters.push(char);
            }
            str = characters.join("");
            console.log(`[${new Date().toISOString()}] String after rotation:`, str);

            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = (31 * hash + str.charCodeAt(i)) % Number.MAX_SAFE_INTEGER;
            }
            const finalHash = hash % 1400000000;
            console.log(`[${new Date().toISOString()}] Final hash calculated:`, finalHash);
            return finalHash;
        }

        const seedValue = hashString("4482324585393f1523e8c28a02605c0b1c95d2779510921da0f131a5e6da5843i0");
        console.log(`[${new Date().toISOString()}] Hash string returned seed value:`, seedValue);

        function seededRandom(localSeed) {
            const x = Math.sin(localSeed) * 10000;
            return x - Math.floor(x);
        }

        function setPlaybackStatus(status) {
            window.playbackStarted = status;
        }

        function initializePlayback() {
            if (window.playbackStarted === undefined) {
                window.playbackStarted = false;
            }

            document.addEventListener("playbackStarted", () => {
                window.psTime = Date.now();
                setPlaybackStatus(true);
                if (typeof displayPlayText === 'function') {
                    displayPlayText();  // Assuming displayPlayText is globally available
                }
            });

            document.addEventListener("playbackStopped", () => {
                setPlaybackStatus(false);
            });
        }

        function enforceDocumentTitle() {
            document.title = "? ? ? ? ? ? ?";
            const titleObserver = new MutationObserver(() => {
                if (document.title !== "? ? ? ? ? ? ?") {
                    document.title = "? ? ? ? ? ? ?";
                }
            });
            titleObserver.observe(document.querySelector("title"), { childList: true, subtree: true });
        }

        const keyMap = {
            0: "projectName", 1: "artistName", 2: "projectBPM", 3: "currentSequence", 
            4: "channelURLs", 5: "channelVolume", 6: "channelPlaybackSpeed", 
            7: "trimSettings", 8: "projectChannelNames", 9: "startSliderValue", 
            10: "endSliderValue", 11: "totalSampleDuration", 12: "start", 
            13: "end", 14: "projectSequences", 15: "steps"
        };

        const reverseKeyMap = Object.fromEntries(Object.entries(keyMap).map(([e, r]) => [r, +e]));
        const channelMap = Array.from({ length: 26 }, (_, r) => String.fromCharCode(65 + r));
        const reverseChannelMap = Object.fromEntries(channelMap.map((e, r) => [e, r]));

        function decompressSteps(e) {
            return e.flatMap(e => {
                if (typeof e === "number") return e;
                if (typeof e === "object" && "r" in e) {
                    const [r, t] = e.r;
                    return Array.from({ length: t - r + 1 }, (e, t) => r + t);
                }
                return typeof e === "string" && e.endsWith("r") ? { index: parseInt(e.slice(0, -1), 10), reverse: true } : void 0;
            });
        }

        function deserialize(e) {
            const r = e => Array.isArray(e) ? e.map(e => typeof e === "object" ? r(e) : e) : typeof e === "object" && e !== null ? Object.entries(e).reduce((e, [t, n]) => {
                const a = keyMap[t] ?? t;
                return e[a] = a === "projectSequences" ? Object.entries(n).reduce((e, [r, t]) => (e[r.replace("s", "Sequence")] = Object.entries(t).reduce((e, [r, t]) => {
                    var n;
                    return e[`ch${reverseChannelMap[r]}`] = { steps: (n = t[reverseKeyMap.steps] || [], n.flatMap(e => {
                        if (typeof e === "number") return e;
                        if (typeof e === "object" && "r" in e) {
                            const [r, t] = e.r;
                            return Array.from({ length: t - r + 1 }, (e, t) => r + t);
                        }
                        return typeof e === "string" && e.endsWith("r") ? { index: parseInt(e.slice(0, -1), 10), reverse: true } : void 0;
                    })) }, e;
                }, {}), e), {}) : r(n), e;
            }, {}) : e;
            return r(e);
        }

        async function loadPako() {
            try {
                const t = await fetch("/content/2109694f44c973892fb8152cf5c68607fb19288c045af1abc1716c1c3b4d69e6i0");
                const o = await t.text();
                const e = document.createElement("div");
                e.innerHTML = o;
                const n = e.querySelectorAll("script");
                const c = Array.from(n).find(t => t.textContent.includes("pako"));
                if (!c) {
                    throw new Error("Pako library not found in the HTML content.");
                }
                const r = document.createElement("script");
                r.textContent = c.textContent;
                document.head.appendChild(r);
            } catch (t) {
                console.error(`Error occurred during Pako loading:`, t);
            }
        }

        async function fetchAndDeserialize(url) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Network response was not ok for URL: ${url}`);
                }
                const arrayBuffer = await response.arrayBuffer();
                const inflated = pako.inflate(new Uint8Array(arrayBuffer));
                const text = new TextDecoder("utf-8").decode(inflated);
                const jsonData = JSON.parse(text);
                return deserialize(jsonData);
            } catch (error) {
                console.error(`Error in fetchAndDeserialize:`, error);
                throw error;
            }
        }

        function shuffleArray(array, localSeed) {
            let currentSeed = localSeed;
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(seededRandom(currentSeed) * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
                currentSeed += 1;
            }
            return array;
        }

        const availableBPMs = [80, 100, 120, 140, 160, 180, 240];

        function selectBPM(availableBPMs, seed) {
            const seededIndex = Math.floor(seededRandom(seed) * availableBPMs.length);
            return availableBPMs[seededIndex];
        }

        async function processSerializedData(urls) {
            try {
                await loadPako();

                const data = await Promise.all(urls.map(async (url) => {
                    try {
                        const result = await fetchAndDeserialize(url);
                        if (!result || !result.projectSequences) {
                            throw new Error(`Invalid data at URL ${url}`);
                        }
                        return result;
                    } catch (error) {
                        console.error(`Error processing URL:`, error);
                        return undefined;
                    }
                }));

                const validData = data.filter(dataset => dataset !== undefined);

                const baseBPM = selectBPM(availableBPMs, window.seed);

                const useHarmonicAdjustment = false;

                validData.forEach((dataset) => {
                    const currentBPM = dataset.projectBPM;
                    const bpmRatio = baseBPM / currentBPM;

                    dataset.channelPlaybackSpeed = dataset.channelPlaybackSpeed.map(speed => {
                        return useHarmonicAdjustment && Math.abs(baseBPM - currentBPM) >= baseBPM / 2
                            ? speed
                            : speed * bpmRatio;
                    });
                });

                const allChannels = [];
                validData.forEach((dataset, datasetIndex) => {
                    for (let index = 0; index < dataset.channelURLs.length; index++) {
                        allChannels.push({
                            url: dataset.channelURLs[index],
                            volume: dataset.channelVolume[index],
                            speed: dataset.channelPlaybackSpeed[index],
                            trim: dataset.trimSettings[index],
                            source: `data${datasetIndex + 1}`,
                            index
                        });
                    }
                });

                const shuffledChannels = shuffleArray(allChannels, window.seed);
                const selectedChannels = shuffledChannels.slice(0, 24);

                const combinedData = {
                    ...validData[0],
                    projectBPM: baseBPM,
                    channelURLs: selectedChannels.map(ch => ch.url),
                    channelVolume: selectedChannels.map(ch => ch.volume),
                    channelPlaybackSpeed: selectedChannels.map(ch => ch.speed),
                    trimSettings: selectedChannels.map(ch => ch.trim),
                    projectSequences: {}
                };

                const projectSequencesSources = validData.reduce((acc, dataset, i) => {
                    acc[`data${i + 1}`] = dataset;
                    return acc;
                }, {});

                for (const seq in validData[0].projectSequences) {
                    combinedData.projectSequences[seq] = {};

                    selectedChannels.forEach((ch, i) => {
                        const chKey = `ch${i}`;
                        const sourceSeq = projectSequencesSources[ch.source]?.projectSequences[seq];

                        if (sourceSeq && sourceSeq[`ch${ch.index}`]) {
                            combinedData.projectSequences[seq][chKey] = sourceSeq[`ch${ch.index}`];
                        } else {
                            combinedData.projectSequences[seq][chKey] = { steps: [] };
                        }
                    });
                }

                const blob = new Blob([JSON.stringify(combinedData)], { type: "application/json" });
                window.jsonDataUrl = URL.createObjectURL(blob);

                try {
                    // Embedding the content of the first external script
                    const scriptContent1 = `
                        function loadScript(e,a){
                            const c=document.createElement("script");
                            c.src=e;
                            c.onload=a;
                            document.head.appendChild(c);
                        }
                        loadScript("/content/d43e19008669597a77865b71018d78c64f83ca36eb961c885ca2a7403f7bf32ci0", function() {
                            console.log("Second script loaded.");
                        });
                    `;

                    // Embedding the content of the second external script
                    const scriptContent2 = `
                        console.log("Deserialized Data URL:", window.jsonDataUrl);
                    `;

                    // Create a script element with the combined content
                    const scriptElement = document.createElement("script");
                    scriptElement.textContent = scriptContent1 + scriptContent2;
                    document.head.appendChild(scriptElement);

                } catch (e) {
                    console.error(`Error processing embedded script content:`, e);
                }

            } catch (e) {
                console.error(`Error processing data in processSerializedData:`, e);
            }
        }

        // Expose functions globally
        window.hashString = hashString;
        window.seededRandom = seededRandom;
        window.setPlaybackStatus = setPlaybackStatus;
        window.initializePlayback = initializePlayback;
        window.enforceDocumentTitle = enforceDocumentTitle;
        window.decompressSteps = decompressSteps;
        window.deserialize = deserialize;
        window.loadPako = loadPako;
        window.fetchAndDeserialize = fetchAndDeserialize;
        window.processSerializedData = processSerializedData;
        window.shuffleArray = shuffleArray;
        window.selectBPM = selectBPM;

        initializePlayback();

        window.onload = function() {
            console.log(`[${new Date().toISOString()}] window.onload triggered.`);
            enforceDocumentTitle();
            if (typeof displayPlayText === 'function') {
                displayPlayText();  // Assuming displayPlayText is globally available
            }
            console.log(`[${new Date().toISOString()}] onload functions executed successfully.`);
        };

        console.log(`[${new Date().toISOString()}] ProcessingModule initialized.`);
    })();

    </script>
    </processingModule>
    </body>
    </html>