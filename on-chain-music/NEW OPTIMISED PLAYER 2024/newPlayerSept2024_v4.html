
<songAndArtworkLinks>
<script>
    let currentSongIndex = 0;  // Initial song index


    const SONGS = [
    {
    songUrl: "https://ordinals.com/content/4653bcc45671abdbc024b03ebbaaadb30e0cad83b80898894ab22426bbccdaaei0",
    artworkUrl: "https://ordinals.com/content/fed62e8fa6c6005c07d5ee1d10811662a71c6a99b59bc79afd7e065aec134bbfi0",
    projectName: "Freedom Remix",
    artistName: "melophonic",
  },
    {
    songUrl: "https://ordinals.com/content/5527d0cc95ce5ce6eedf4e275234da8b1fe087512d0db618b6de1aaad437c96bi0",
    artworkUrl: "https://ordinals.com/content/cf997386e346140d3d5dbaedbe015c63d81df962a8cc87fc0b571b429d4778b5i5",
    projectName: "TRUTH",
    artistName: "melophonic",
  },

  {
    songUrl: "https://ordinals.com/content/8aec0a99a5617b9da98a5b63a11a5143f0cac3cfa662d9515c2285de03ef95d4i0",
    artworkUrl: "https://ordinals.com/content/53381703b96cf1575de69a870e0a731f3bae23218ee35fd7b00cd195ba2c7a39i0",
    projectName: "I LOVE CHEESE",
    artistName: "Rex Speedway and The Denim Avengers",
  },
  {
    songUrl: "https://ordinals.com/content/633100d631767ddb9a309f5a2a66f5a66d5abd839f3b1c55642690d484189971i0",
    artworkUrl: "https://ordinals.com/content/2df6f9e192bb34059aabada179857cdcce7891be92fa20a49a66850de8f75a00i0",
    projectName: "ON DAY ONE",
    artistName: "based.btc",
  },
  {
    songUrl: "https://ordinals.com/content/6d288c0c82653001bb32497889dd1486e8afec9b0671a95fa9e10f99c20737bbi0",
    artworkUrl: "https://ordinals.com/content/dad995f3f46254e73b0470e7ac7e25a874db400324d22c1e2abd8cbf2bebd00ai0",
    projectName: "Kora algo",
    artistName: "melophonic",
  },

  {
    songUrl: "https://ordinals.com/content/b22f1c85371b58a9cdac19b2baa50b1f9025a28d44cdfaad539d0527aa7d894ei0",
    artworkUrl: "https://ordinals.com/content/3a95675d62bd78af488ef60e56f904d0af73e9e54096fba160488381a3a494b2i0",
    projectName: "ON-CHAIN IN THE MEMBRANE",
    artistName: "melophonic",
  },

  {
    songUrl: "https://ordinals.com/content/9dfa1812b211a7ac8b2f9e77119828ec8fbf2e9016b3d37a8efd70052eb4aa3ci0",
    artworkUrl: "https://ordinals.com/content/918b25dadc46459e6632532980968e2b79af04198c56f3f4715f79c20b12e886i0",
    projectName: "Butterfly Effect",
    artistName: "based.btc",
  },

  {
    songUrl: "https://ordinals.com/content/db9131cfe8e933e8e639f007dcd2b582a80bfd2be42b0eafa4d2e206332d6785i0",
    artworkUrl: "https://ordinals.com/content/5a5255d440a282e92444f3d061a4c2565c0a1e26f29f4e24d3d4ce83cbd5071bi0",
    projectName: "MODERN PROGRESS",
    artistName: "melophonic",
  },
  {
    songUrl: "https://ordinals.com/content/fb0d2abcd1fa5bf2622579f0990435b48d41291f71626fc2e36a93e6ea6b3b85i0",
    artworkUrl: "https://ordinals.com/content/a5475f4d624e0517713ededa758dba0304ee0265c1ed8d5aae6615b2139643c8i0",
    projectName: "HUMANITY",
    artistName: "melophonic",
  },

  {
    songUrl: "https://ordinals.com/content/119a3ccd1dfd7e987cca139f86d16717d845a22dd6afc59ad492527b95ae9a91i0",
    artworkUrl: "https://ordinals.com/content/26b15064aaab0f2b10555d37193587c4e4d69801f9af339b7b03fb2a839a6f85i0",
    projectName: "MLK",
    artistName: "melophonic",
  },


  {
    songUrl: "https://ordinals.com/content/3359ce42359274ddbd2184d9f75a38b7e59b1d5f24512959e29c377fc8ca604ai0",
    artworkUrl: "https://ordinals.com/content/8a234e2de569147ed58a86dc59fb4a37e577b702ce49fdf119fbdbe274f30e70i0",
    projectName: "FRESH VIBES",
    artistName: "melophonic",
  },



  {
    songUrl: "https://ordinals.com/content/07ff7bdc47e5272a3ff55cc46d2b189d510562a057a2c24112f3d0376950484di0",
    artworkUrl: "https://ordinals.com/content/ec99785b253c01583e6041e981a7a47134553fae57947e9d0c6c8949bd9e3bf1i0",
    projectName: "Choppin' It Up",
    artistName: "melophonic",
  },



];

</script>
</songAndArtworkLinks>

<loadPako>
<script>
    // pakoLoader.js
  
    (() => {
        const PAKO_URL = "https://ordinals.com/content/2109694f44c973892fb8152cf5c68607fb19288c045af1abc1716c1c3b4d69e6i0";
        let pakoLoaded = false; // Flag to track if Pako is loaded
  
        /**
         * Loads the Pako library from the specified URL.
         */
        async function loadPako() {
            try {
                const res = await fetch(PAKO_URL, { cache: "force-cache" }); // Utilize caching
                if (!res.ok) throw new Error(`Network error: ${res.statusText}`);
  
                const text = await res.text();
                const scriptContent = new DOMParser()
                    .parseFromString(text, "text/html")
                    .querySelector("script")?.textContent;
  
                if (!scriptContent || !scriptContent.includes("pako")) {
                    throw new Error("Pako library not found in the fetched content.");
                }
  
                // Validate the script content (basic validation)
                if (!isValidPakoScript(scriptContent)) {
                    throw new Error("Invalid Pako library script.");
                }
  
                appendScriptToHead(scriptContent);
                console.log("Pako library loaded successfully.");
  
                await waitForPako();
                pakoLoaded = true; // Mark Pako as loaded
  
                // Dispatch a custom event to notify that Pako is loaded
                document.dispatchEvent(new Event('pakoLoaded'));
  
            } catch (err) {
                console.error("Error during Pako loading:", err);
                displayError("Failed to load necessary libraries. Please try again later.");
                // Optionally, implement retry logic here
            }
        }
  
        /**
         * Validates the fetched Pako script content.
         * @param {string} script - The script content to validate.
         * @returns {boolean} - True if valid, else false.
         */
        function isValidPakoScript(script) {
            // Implement additional validation if necessary
            // For example, check for specific function definitions or patterns
            return typeof script === "string" && script.includes("pako");
        }
  
        /**
         * Appends the provided script content to the document head.
         * @param {string} scriptContent - The script content to append.
         */
        function appendScriptToHead(scriptContent) {
            const scriptElement = document.createElement("script");
            scriptElement.type = "text/javascript";
            scriptElement.textContent = scriptContent;
            document.head.appendChild(scriptElement);
        }
  
        /**
         * Waits for the Pako library to be available within the specified timeout.
         * @param {number} timeout - The maximum time to wait in milliseconds.
         * @returns {Promise} - Resolves when Pako is loaded, rejects on timeout.
         */
        function waitForPako(timeout = 5000) { // Increased timeout for reliability
            return new Promise((resolve, reject) => {
                let elapsed = 0;
                const interval = 50;
                const checkPako = () => {
                    if (typeof pako !== 'undefined') {
                        resolve();
                    } else {
                        elapsed += interval;
                        if (elapsed >= timeout) {
                            reject(new Error("Pako library failed to load within the timeout period."));
                        } else {
                            setTimeout(checkPako, interval);
                        }
                    }
                };
                checkPako();
            });
        }
  
        /**
         * Displays an error message to the user.
         * @param {string} message - The error message to display.
         */
        function displayError(message) {
            const errorElem = document.getElementById("errorMessage");
            if (errorElem) {
                errorElem.textContent = message;
                errorElem.style.display = "block";
            } else {
                // Fallback: Create an error element if not present
                const newErrorElem = document.createElement("div");
                newErrorElem.id = "errorMessage";
                newErrorElem.textContent = message;
                newErrorElem.style.color = "red";
                document.body.prepend(newErrorElem);
            }
        }
  
        /**
         * Initializes the application after Pako is loaded.
         * Ensure that this function is defined in the global scope or within your app's context.
         */
        function initializeApp() {
            if (typeof window.initializeApp === "function") {
                window.initializeApp();
            } else {
                console.warn("initializeApp function is not defined.");
            }
        }
  
        /**
         * Ensures that the Pako library is loaded once the DOM is ready.
         */
        function onDOMContentLoaded() {
            if (document.readyState === "loading") {
                document.addEventListener("DOMContentLoaded", loadPako);
            } else {
                // DOMContentLoaded already fired
                loadPako();
            }
        }
  
        // Initialize the loader
        onDOMContentLoaded();
  
        // Expose pakoLoaded flag if needed
        window.isPakoLoaded = () => pakoLoaded;
    })();
</script>
</loadPako>

<initialiseApp>
    <script>
      // Initialization Script
  
      /**
       * Function to initialize the application after Pako is loaded
       */
      function initializeApp() {
        try {
          // Ensure Pako is loaded before initializing
          if (!window.isPakoLoaded()) {
            throw new Error("Pako library not loaded.");
          }
  
          // Initialize your application here
          setupEventListeners();
          console.log("Application initialized successfully.");
          loadSong(currentSongIndex); // Load the initial song
          preloadAllSongs(); // Preload all songs
        } catch (error) {
          // Delay the error logging by 1 second
          setTimeout(() => {
            // Check again before logging the error, if Pako was loaded
            if (!window.isPakoLoaded()) {
              console.error("Initialization failed:", error);
              displayError("Initialization failed. Please try again later.");
            }
          }, 1000);
        }
      }
  
      // Function to set up event listeners and other initialization tasks
      function setupEventListeners() {
        const loadButton = document.getElementById("loadButton");
        const playButton = document.getElementById("playButton");
        const stopButton = document.getElementById("stopButton");
        const skipBackButton = document.getElementById("skipBackButton");
        const skipForwardButton = document.getElementById("skipForwardButton");
  
        loadButton.addEventListener("click", handleLoad);
        playButton.addEventListener("click", handlePlay);
        stopButton.addEventListener("click", handleStop);
        skipBackButton.addEventListener("click", () => handleSkip(-10)); // Example: Skip back 10 seconds
        skipForwardButton.addEventListener("click", () => handleSkip(10)); // Example: Skip forward 10 seconds
  
        // Additional setup as needed
      }
  
      // Placeholder functions for button handlers
      function handleLoad() {
        // Load the current song
        loadSong(currentSongIndex);
        console.log(`Load button clicked. Loaded song index: ${currentSongIndex}`);
      }
  
      function handlePlay() {
        // Implement play functionality
        const audio = getAudioElement();
        if (audio) {
          audio.play();
          console.log("Play button clicked.");
        }
      }
  
      function handleStop() {
        // Implement stop functionality
        const audio = getAudioElement();
        if (audio) {
          audio.pause();
          audio.currentTime = 0;
          console.log("Stop button clicked.");
        }
      }
  
      function handleSkip(seconds) {
        // Implement skip functionality
        const audio = getAudioElement();
        if (audio) {
          audio.currentTime += seconds;
          console.log(`Skip ${seconds > 0 ? 'forward' : 'back'} by ${Math.abs(seconds)} seconds.`);
        }
      }
  
      /**
       * Function to get or create the audio element
       */
      function getAudioElement() {
        let audio = document.getElementById("audioPlayer");
        if (!audio) {
          audio = document.createElement("audio");
          audio.id = "audioPlayer";
          audio.controls = true;
          audio.style.display = "none"; // Hide the default controls
          document.body.appendChild(audio);
  
          // Update UI when audio ends
          audio.addEventListener('ended', () => {
            console.log("Song ended.");
            // Optionally, load the next song automatically
            // loadNextSong();
          });
        }
        return audio;
      }
  
      /**
       * Function to load a song based on the currentSongIndex
       * Updates the song title, artist name, and artwork in the UI
       */
      function loadSong(index) {
        const song = SONGS[index];
        if (!song) {
          console.error(`Song at index ${index} does not exist.`);
          displayError("Requested song does not exist.");
          return;
        }
  
        const audio = getAudioElement();
        audio.src = song.songUrl;
        audio.load();
  
        // Update song title and artist name
        document.getElementById("songTitle").textContent = song.projectName;
        document.getElementById("artistName").textContent = song.artistName;
  
        // Update artwork
        const artworkCanvas = document.getElementById("artworkCanvas");
        artworkCanvas.innerHTML = ''; // Clear previous artwork
  
        const img = document.createElement("img");
        img.id = "currentArtwork";
        img.src = song.artworkUrl;
        img.alt = `${song.projectName} Artwork`;
        artworkCanvas.appendChild(img);
  
        console.log(`Loaded song: ${song.projectName} by ${song.artistName}`);
      }
  
      /**
       * Function to preload all songs (ensure this runs after Pako is loaded)
       */
      async function preloadAllSongs() {
        try {
          await Promise.all(SONGS.map(async (song, index) => {
            // Preload song logic that may use Pako
            const response = await fetch(song.songUrl);
            if (!response.ok) {
              throw new Error(`Failed to fetch song at index ${index}: ${response.statusText}`);
            }
            const arrayBuffer = await response.arrayBuffer();
            const compressedData = pako.deflate(new Uint8Array(arrayBuffer));
            // Store compressedData as needed
            console.log(`Song ${index} (${SONGS[index].projectName}) compressed.`);
          }));
          console.log("All songs preloaded and compressed.");
        } catch (error) {
          console.error("Error preloading songs:", error);
          displayError("Some songs failed to preload.");
        }
      }
  
      /**
       * Function to display error messages to the user
       */
      function displayError(message) {
        const errorElem = document.getElementById("errorMessage");
        if (errorElem) {
          errorElem.textContent = message;
          errorElem.style.display = "block";
        } else {
          // Fallback: Create an error element if not present
          const newErrorElem = document.createElement("div");
          newErrorElem.id = "errorMessage";
          newErrorElem.textContent = message;
          newErrorElem.style.color = "red";
          document.body.prepend(newErrorElem);
        }
      }
  
      /**
       * Waits for the Pako library to be loaded before initializing the app.
       * Listens for the custom 'pakoLoaded' event dispatched by pakoLoader.js.
       */
      function waitForPakoAndInitialize() {
        if (window.isPakoLoaded()) {
          // If Pako is already loaded, initialize immediately
          initializeApp();
        } else {
          // Otherwise, wait for the 'pakoLoaded' event
          document.addEventListener('pakoLoaded', initializeApp);
        }
      }
  
      // Start the initialization process after Pako is loaded
      waitForPakoAndInitialize();
  
      /**
       * Optional: Functions to navigate between songs
       */
      function loadNextSong() {
        currentSongIndex = (currentSongIndex + 1) % SONGS.length;
        loadSong(currentSongIndex);
      }
  
      function loadPreviousSong() {
        currentSongIndex = (currentSongIndex - 1 + SONGS.length) % SONGS.length;
        loadSong(currentSongIndex);
      }
  
      // Example: Add event listeners for next and previous buttons if they exist
      /*
      document.getElementById("nextButton").addEventListener("click", loadNextSong);
      document.getElementById("previousButton").addEventListener("click", loadPreviousSong);
      */
    </script>
  </initialiseApp>
  
  


<!-- Styles for the application -->
<style>
    body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        background-color: #000000;
        justify-content: flex-start;
        align-items: center;
    }

    h1 {
        color: #333;
        margin: 10px 0;
        font-size: 1.2rem; /* Smaller font size */
    }

    #buttonContainer {
        display: flex;
        gap: 5px; /* Smaller gap */
        margin-bottom: 10px;
        margin-top: 10px;
    }

    button {
        padding: 5px 10px; /* Smaller padding */
        cursor: pointer;
        font-size: 0.8rem; /* Smaller font size */
    }

    #loadingIndicator, #errorMessage, #songTitle, #artistName {
        margin-top: 5px;
        font-size: 0.9rem; /* Smaller font size */
        color: #ffffff; /* White text for better visibility */
    }

    #loadingIndicator {
        display: block; /* Initially visible */
    }

    #errorMessage {
        display: none; /* Hidden by default */
        color: red;
    }
    .close-btn {
        position: absolute;
        top: 20px;
        right: 20px;
        background-color: #ff0000;
        color: white;
        border: none;
        padding: 10px;
        cursor: pointer;
        display: none; /* Hidden by default */
        z-index: 1000; /* Ensure it's on top */
        border-radius: 50%;
    }

        /* Fade-out effect for the close button */
        .fade-out {
            animation: fadeOut 2s forwards;
        }

        @keyframes fadeOut {
            to {
                opacity: 0;
            }
        }


    #artworkCanvas {
        width: 66vh; /* Set the width to be the same as 66% of the viewport height */
        height: 66vh; /* Set the height to 66% of the viewport height */
        display: flex;
        justify-content: center;
        align-items: center;
        border: 2px solid #333;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        background-color: #f9f9f9;
        margin-top: auto;
        margin-bottom: auto;
        aspect-ratio: 1 / 1; /* Ensure the canvas is always square */
    }

    img, video, iframe {
        max-width: 100%;
        max-height: 100%;
        object-fit: contain;
    }

    .unsupported {
        color: red;
        font-size: 14px;
    }
</style>

</head>
<body>
<h1>Audional Player</h1>
<div id="buttonContainer">
    <button id="loadButton">Load</button>
    <button id="playButton" disabled>Play</button>
    <button id="stopButton" disabled>Stop</button>
    <button id="skipBackButton" disabled>Skip &lt;</button>
    <button id="skipForwardButton" disabled>Skip &gt;</button>
    <button id="fullscreenButton">Fullscreen</button> <!-- Fullscreen button -->
</div>
<div id="closeButton" class="close-btn">X</div> <!-- Close button -->

<div id="loadingIndicator">Loading...</div>
<div id="errorMessage"></div>
<div id="songTitle"></div>
<div id="artistName"></div>
<div id="artworkCanvas">
    <img id="placeholderImage" src="https://ordinals.com/content/01c48d3cceb02215bc3d44f9a2dc7fba63ea63719a2ef1c35d3f0c4db93ab8d5i0" alt="Placeholder Artwork" />
</div>
<artworkCanvasSettings>
<script>
    const fullscreenButton = document.getElementById('fullscreenButton');
    const closeButton = document.getElementById('closeButton');
    const artworkCanvas = document.getElementById('artworkCanvas');
    
    let closeButtonVisible = false;
    
    fullscreenButton.addEventListener('click', () => {
        if (document.fullscreenElement) {
            document.exitFullscreen();
        } else {
            artworkCanvas.requestFullscreen();
        }
    });
    
    document.addEventListener('fullscreenchange', () => {
        if (document.fullscreenElement) {
            artworkCanvas.style.width = '100vw';
            artworkCanvas.style.height = '100vh';
            closeButton.style.display = 'block'; // Show close button
            closeButtonVisible = true;
    
            // Fade out the close button after a few seconds
            setTimeout(() => {
                if (!closeButtonVisible) return;
                closeButton.classList.add('fade-out');
            }, 3000);
        } else {
            artworkCanvas.style.width = '66vh';
            artworkCanvas.style.height = '66vh';
            closeButton.style.display = 'none'; // Hide close button
            closeButton.classList.remove('fade-out');
            closeButtonVisible = false;
        }
    });
    
    // Show close button when mouse moves in fullscreen
    document.addEventListener('mousemove', () => {
        if (document.fullscreenElement) {
            closeButton.style.display = 'block';
            closeButton.classList.remove('fade-out');
            closeButtonVisible = true;
    
            // Reset fade-out timer
            setTimeout(() => {
                if (!closeButtonVisible) return;
                closeButton.classList.add('fade-out');
            }, 3000);
        }
    });
    
    // Close button functionality
    closeButton.addEventListener('click', () => {
        document.exitFullscreen();
    });
    
    // Handle mouse movement to keep the close button visible
    closeButton.addEventListener('mouseover', () => {
        closeButtonVisible = true;
        closeButton.style.display = 'block';
        closeButton.classList.remove('fade-out');
    });
    
    </script>
    </artworkCanvasSettings>

    
<script>

        document.addEventListener('DOMContentLoaded', () => {
            const keyMap = {
                            "0": "projectName", "1": "artistName", "2": "projectBPM", "3": "currentSequence",
                            "4": "channelURLs", "5": "channelVolume", "6": "channelPlaybackSpeed", "7": "trimSettings",
                            "8": "projectChannelNames", "9": "startSliderValue", "10": "endSliderValue", "11": "totalSampleDuration",
                            "12": "start", "13": "end", "14": "projectSequences", "15": "steps"
                        };
                        const reverseKeyMap = Object.fromEntries(Object.entries(keyMap).map(([k, v]) => [v, k]));

                        const decompressSteps = (steps) =>
                                steps.map(step => {
                                    if (typeof step === "number") return { index: step, reverse: false };
                                    if (typeof step === "string" && step.endsWith("r")) return { index: parseInt(step.slice(0, -1), 10), reverse: true };
                                    if (typeof step === "object" && step.r) return { index: step.r[0], reverse: Boolean(step.r[1]) };
                                    console.warn("Unknown step format:", step);
                                    return null;
                                }).filter(Boolean);

                                const letterToNumber = (() => {
                                    const map = Object.fromEntries([...Array(16)].map((_, i) => [String.fromCharCode(97 + i), i]));
                                    return (letter) => map[letter.toLowerCase()] ?? null;
                                })();

                                const deserialize = (data) =>
                                    Object.fromEntries(Object.entries(data).map(([key, value]) => {
                                        const mappedKey = keyMap[key] || key;
                                        if (mappedKey === "projectSequences") {
                                            return [mappedKey, Object.fromEntries(Object.entries(value).map(([seqKey, seqValue]) => {
                                                const sequenceId = `Sequence${seqKey.replace(/^s/, "")}`;
                                                const channels = Object.fromEntries(Object.entries(seqValue).map(([chanKey, chanData]) => {
                                                    let channelNumber = parseInt(chanKey.replace(/^ch/, ""), 10);
                                                    channelNumber = isNaN(channelNumber) ? letterToNumber(chanKey) : channelNumber;
                                                    return channelNumber !== null ? [`Channel ${channelNumber}`, { steps: decompressSteps(chanData[reverseKeyMap.steps] || []) }] : [];
                                                }).filter(Boolean));
                                                return [sequenceId, channels];
                                            }))];
                                        }
                                        return [mappedKey, value];
                                    }));



class AudioPlayer {
    constructor() {
        this.initializeProperties();
        this.bindUIElements();
        this.initEventListeners();
    }

    initializeProperties() {
        this.projectNames = [];
        this.songLoadCounter = 0;
        this.totalSongs = SONGS.length;
        this.audioBuffers = [];
        this.reversedAudioBuffers = {};
        this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        this.isPlaying = false;
        this.currentSourceNodes = [];
        this.processedData = {};
        this.currentSequence = 0;
        this.startTime = 0;
        this.pendingTimeouts = [];
    }

    bindUIElements() {
        ['loadButton', 'playButton', 'stopButton', 'skipForwardButton', 'skipBackButton', 'loadingIndicator', 'errorMessage', 'songTitle', 'artistName', 'artworkCanvas']
            .forEach(id => this[id] = document.getElementById(id));
    }

    initEventListeners() {
        this.loadButton.addEventListener('click', () => this.loadButtonHandler());
        this.playButton.addEventListener('click', () => this.play());
        this.stopButton.addEventListener('click', () => this.stop());
        this.skipForwardButton.addEventListener('click', () => this.skipSong('forward'));
        this.skipBackButton.addEventListener('click', () => this.skipSong('back'));
    }

    showSongTitle(title) {
        this.songTitle.textContent = title;
    }

    showArtistName(name) {
        this.artistName.textContent = name;
    }
    
    async loadSong(url, autoPlay = false) {
        this.reset();
        try {
            this.showLoading(true);
            await this.loadGzipSongFile(url);
            this.toggleButtons(false);
            
            // Get the current song from the SONGS array
            const song = SONGS[currentSongIndex];
            if (song) {
                // Update the UI with the song's project name and artist name
                this.showSongTitle(song.projectName || "Unknown Title");
                this.showArtistName(song.artistName || "Unknown Artist");
                
                // Display the artwork if available
                if (song.artworkUrl) {
                    await this.displayArtwork(song.artworkUrl);
                } else {
                    console.warn(`No artwork URL found for song at index ${currentSongIndex}`);
                }
            } else {
                this.showSongTitle("Unknown Title");
                this.showArtistName("Unknown Artist");
                console.warn(`No song found at index ${currentSongIndex}`);
            }

            if (autoPlay) this.play();
        } catch (e) {
            console.error("Error loading file:", e);
            this.displayError("Failed to load file.");
        } finally {
            this.showLoading(false);
        }
    }


async displayArtwork(url) {
    this.artworkCanvas.innerHTML = ''; // Clear the artwork canvas
    try {
        const res = await fetch(url, { method: 'HEAD' });
        if (!res.ok) throw new Error(`Failed to fetch artwork: ${res.status}`);
        const contentType = res.headers.get('Content-Type');
        const mediaElement = this.createMediaElement(contentType, url, currentSongIndex); // Pass the currentSongIndex for alt text
        this.artworkCanvas.appendChild(mediaElement);
    } catch (error) {
        console.error(`Error displaying artwork:`, error);
        this.artworkCanvas.appendChild(this.createErrorElement('Failed to load artwork.'));
    }
}

createMediaElement(contentType, url, songIndex) {
    const elements = {
        image: () => {
            const img = Object.assign(document.createElement('img'), {
                src: url,
                alt: `Artwork for song ${songIndex + 1}`, // Use the current song index for alt text
                onload: () => this.fitMediaElement(this.artworkCanvas, img) // Fit the image within the canvas
            });
            return img;
        },
        video: () => Object.assign(document.createElement('video'), { src: url, controls: true }),
        audio: () => Object.assign(document.createElement('audio'), { src: url, controls: true }),
        html: () => Object.assign(document.createElement('iframe'), { src: url, width: '100%', height: '100%', frameBorder: 0 })
    };

    const type = contentType.split('/')[0]; // Get the type (image, video, audio, etc.)
    return elements[type] ? elements[type]() : this.createErrorElement('Unsupported artwork format.');
}

    fitMediaElement(container, element) {
        if (!element || !element.naturalWidth || !element.naturalHeight) {
            console.error('Element is undefined or does not have natural dimensions.');
            return;
        }

        const { clientWidth: w, clientHeight: h } = container;
        const imgAspect = element.naturalWidth / element.naturalHeight;
        const canvasAspect = w / h;

        element.style.width = imgAspect > canvasAspect ? '100%' : 'auto';
        element.style.height = imgAspect > canvasAspect ? 'auto' : '100%';
    }


    createErrorElement(message) {
        return Object.assign(document.createElement('div'), { className: 'unsupported', textContent: message });
    }


   
    toggleButtons(disabled) {
        [this.playButton, this.stopButton, this.skipForwardButton, this.skipBackButton].forEach(btn => btn.disabled = disabled);
    }

    async loadButtonHandler() {
        await this.loadSong(SONGS[currentSongIndex].songUrl);
    }

    async skipSong(direction) {
        currentSongIndex = (direction === 'forward') 
            ? (currentSongIndex + 1) % SONGS.length 
            : (currentSongIndex - 1 + SONGS.length) % SONGS.length;
        await this.loadSong(SONGS[currentSongIndex].songUrl, this.isPlaying);
    }

    reset() {
        this.stop();
        this.audioBuffers = [];
        this.reversedAudioBuffers = {};
        this.currentSourceNodes.forEach(s => s.stop?.());
        this.currentSourceNodes = [];
        this.pendingTimeouts.forEach(clearTimeout);
        this.pendingTimeouts = [];
        this.processedData = {};
        this.currentSequence = this.startTime = 0;
        this.toggleButtons(true);
        this.artworkCanvas.innerHTML = '';
    }

    showLoading(isLoading) {
        this.loadingIndicator.style.display = isLoading ? 'block' : 'none';
    }

    displayError(message) {
        this.errorMessage.textContent = message;
    }



    async loadGzipSongFile(url) {
    try {
        const res = await fetch(url);
        if (!res.ok) throw new Error(`Network response not ok: ${res.statusText}`);

        const data = deserialize(JSON.parse(new TextDecoder().decode(pako.inflate(new Uint8Array(await res.arrayBuffer())))));
        
        // Removed the following lines as we are now using SONGS array for names
        // const projectName = data.projectName || 'NoName';
        // this.showSongTitle(projectName);
        // this.projectNames.push(projectName);

        const metadata = {
            // Use the song details from the SONGS array instead of data
            // projectName, artistName are now fetched from SONGS in loadSong
            projectBPM: data.projectBPM,
            currentSequence: data.currentSequence,
            channelURLs: this.arrayToObject(data.channelURLs),
            channelVolume: this.arrayToObject(data.channelVolume, 0, true),
            channelPlaybackSpeed: this.arrayToObject(data.channelPlaybackSpeed, 0, true),
            trimSettings: this.mapTrimSettings(data.trimSettings),
            projectChannelNames: data.projectChannelNames,
            projectSequences: data.projectSequences,
            globalPlaybackSpeed: data.globalPlaybackSpeed || 1,
        };

        this.processedData = {
            ...metadata,
            VOLUME_CONTROLS: metadata.channelVolume,
            SPEED_CONTROLS: metadata.channelPlaybackSpeed,
            songDataUrls: Object.values(metadata.channelURLs),
        };

        console.log(`Sequences loaded: ${Object.keys(this.processedData.projectSequences).length}`);

        if (this.processedData.songDataUrls.length === 16) {
            await this.fetchAndProcessAudioData(this.processedData.songDataUrls.map(u => `https://ordinals.com${u}`));
        } else {
            throw new Error("Invalid channel URLs or channel count.");
        }

        if (++this.songLoadCounter === this.totalSongs) this.logProjectNames();
    } catch (error) {
        console.error(`Error loading file:`, error);
    }
}


    arrayToObject(arr, start = 0, parse = false) {
    return arr.reduce((obj, val, idx) => {
        obj[`Channel ${start + idx}`] = parse ? parseFloat(val) || 1 : val;
        return obj;
    }, {});
}

mapTrimSettings(arr) {
    return arr.reduce((obj, item, idx) => {
        obj[`Channel ${idx}`] = typeof item === 'object' && item
            ? { start: item[9] || 0, end: item[10] || 100 }
            : { start: 0, end: typeof item === 'number' ? item : 100 };
        if (typeof item !== 'object' && typeof item !== 'number') console.warn(`Invalid trim for Channel ${idx}.`);
        return obj;
    }, {});
}

async fetchAndProcessAudioData(urls) {
    const results = await Promise.allSettled(urls.map(this.processAudioUrl.bind(this)));
    results.forEach((res, i) => res.status === 'rejected' && console.error(`Failed Channel ${i} (${urls[i]}):`, res.reason));
    this.createReversedBuffers();
}

async processAudioUrl(url, index) {
    const channelName = `Channel ${index}`;
    try {
        const res = await fetch(url);
        if (!res.ok) throw new Error(`Fetch failed: ${url}, Status: ${res.status}`);

        const audioBuffer = await this.handleResponseByType(res, res.headers.get("Content-Type"), channelName);
        if (audioBuffer) {
            this.logAudioBufferDetails(audioBuffer, channelName);
            this.storeAudioBuffer(audioBuffer, channelName);
        }
    } catch (error) {
        console.error(`Error processing ${channelName}:`, error);
    }
}

async handleResponseByType(response, contentType, channelName) {
    if (/audio|video/.test(contentType)) {
        return this.fetchAndDecodeAudio(response, channelName);
    }
    if (/json/.test(contentType)) {
        return this.handleResponse(response, channelName, 'JSON'); // Unified response handling
    }
    if (/html/.test(contentType)) {
        return this.handleResponse(response, channelName, 'HTML'); // Unified response handling
    }
    throw new Error(`Unsupported content type for ${channelName}: ${contentType}`);
}

async handleResponse(response, channelName, type) {
    return this.handleAudioDataFromResponse(response, channelName, type);
}

logAudioBufferDetails(audioBuffer, channelName) {
    console.log(`AudioBuffer for ${channelName}:`, {
        channels: audioBuffer.numberOfChannels,
        length: audioBuffer.length,
        sampleRate: audioBuffer.sampleRate,
        duration: audioBuffer.duration,
    });
    [...Array(audioBuffer.numberOfChannels).keys()].forEach(c =>
        console.log(`Channel ${c} data:`, audioBuffer.getChannelData(c).slice(0, 10))
    );
}

storeAudioBuffer(audioBuffer, channelName) {
    const { VOLUME_CONTROLS, SPEED_CONTROLS, trimSettings } = this.processedData;
    const volume = this.parseVolumeLevel(VOLUME_CONTROLS[channelName]);
    const speed = SPEED_CONTROLS[channelName] || 1;
    const trim = trimSettings[channelName] || { start: 0, end: 100 };
    const trimmedBuffer = this.applyTrim(audioBuffer, trim.start, trim.end);

    const gainNode = this.audioCtx.createGain();
    gainNode.gain.value = volume;
    gainNode.connect(this.audioCtx.destination);

    this.audioBuffers.push({ buffer: trimmedBuffer, gainNode, channel: channelName, playbackSpeed: speed });
}

async fetchAndDecodeAudio(response, channelName) {
    try {
        const arrayBuffer = await response.arrayBuffer();
        const audioBuffer = await this.audioCtx.decodeAudioData(arrayBuffer);
        console.log(`Decoded ${channelName}.`);
        return audioBuffer;
    } catch (error) {
        console.error(`decodeAudioData failed for ${channelName}:`, error);
        throw new Error(`Failed to decode audio for ${channelName}.`);
    }
}


async handleAudioDataFromResponse(response, channelName, type) {
    try {
        const data = type === 'JSON' ? await response.json() : await response.text();
        const base64Audio = type === 'JSON' ? data.audioData : this.extractBase64FromHTML(data);
        
        if (base64Audio) {
            const arrayBuffer = this.base64ToArrayBuffer(base64Audio.split(",")[1]);
            try {
                const audioBuffer = await this.audioCtx.decodeAudioData(arrayBuffer);
                return audioBuffer;
            } catch (error) {
                console.error(`decodeAudioData failed for ${type} audio data in ${channelName}:`, error);
                throw new Error(`Failed to decode ${type} audio data for ${channelName}.`);
            }
        }
        throw new Error(`Invalid ${type} structure for audio data in ${channelName}.`);
    } catch (error) {
        console.error(`Error handling ${type} response for ${channelName}:`, error);
        throw error;
    }
}

    base64ToArrayBuffer(base64) {
        try {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        } catch (error) {
            console.error("[base64ToArrayBuffer] Conversion error:", error);
            return null;
        }
    }

    extractBase64FromHTML(htmlContent) {
        try {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlContent, "text/html");
            const audioSource = doc.querySelector("audio[data-audionalSampleName] source")?.getAttribute("src");
            if (/^data:audio\/(wav|mp3|mp4);base64,/.test(audioSource?.toLowerCase()) || /audio\//.test(audioSource?.toLowerCase())) {
                return audioSource;
            }
            console.error("[extractBase64FromHTML] Invalid audio source format.");
        } catch (error) {
            console.error("[extractBase64FromHTML] Parsing error:", error);
        }
        return null;
    }

    parseVolumeLevel(volume) {
    return Math.max(0, Math.min(parseFloat(volume) || 1, 1));
}

applyTrim(buffer, startPercent, endPercent) {
    const totalSamples = buffer.length;
    const [startSample, endSample] = [startPercent, endPercent].map(p => Math.floor(totalSamples * (p / 100)));

    if (startSample >= endSample || startSample < 0 || endSample > totalSamples) {
        console.warn(`Invalid trim settings: Start = ${startPercent}%, End = ${endPercent}%. Using full buffer.`);
        return buffer;
    }

    const trimmedBuffer = this.audioCtx.createBuffer(buffer.numberOfChannels, endSample - startSample, buffer.sampleRate);
    buffer.numberOfChannels && Array.from({ length: buffer.numberOfChannels }).forEach((_, channel) => {
        trimmedBuffer.copyToChannel(buffer.getChannelData(channel).subarray(startSample, endSample), channel);
    });

    return trimmedBuffer;
}


createReversedBuffers() {
    const channelsWithReverse = new Set();
    console.debug("Starting createReversedBuffers");

    Object.values(this.processedData.projectSequences).forEach((sequence, seqIndex) => {
        console.debug(`Processing sequence ${seqIndex + 1}/${Object.keys(this.processedData.projectSequences).length}`);
        Object.entries(sequence).forEach(([channelName, channelData]) => {
            channelData.steps.forEach(({ reverse }, stepIndex) => {
                if (reverse) {
                    channelsWithReverse.add(channelName);
                    console.debug(`  Step ${stepIndex + 1}: Reverse flag set for channel '${channelName}'`);
                }
            });
        });
    });

    console.debug("Channels requiring reversal:", Array.from(channelsWithReverse));

    this.audioBuffers.forEach(({ buffer, channel }) => {
        if (channelsWithReverse.has(channel)) {
            if (!this.reversedAudioBuffers[channel]) {
                console.debug(`Reversing buffer for channel: ${channel}`);
                this.reversedAudioBuffers[channel] = this.reverseBuffer(buffer);
            } else {
                console.debug(`Buffer for channel ${channel} already reversed.`);
            }
        }
    });

    console.debug("Completed createReversedBuffers");
}


    reverseBuffer(buffer) {
        console.debug("Starting reverseBuffer");
        const reversedBuffer = this.audioCtx.createBuffer(buffer.numberOfChannels, buffer.length, buffer.sampleRate);

        for (let channel = 0; channel < buffer.numberOfChannels; channel++) {
            const channelData = buffer.getChannelData(channel);
            const reversedData = reversedBuffer.getChannelData(channel);
            console.debug(`  Reversing data for channel ${channel + 1}/${buffer.numberOfChannels}`);
            
            for (let i = 0, len = buffer.length; i < len; i++) {
                reversedData[i] = channelData[len - i - 1];
            }
        }

        console.debug("Completed reverseBuffer");
        return reversedBuffer;
    }
// Playback methods
play() {
    if (this.isPlaying) return;
    this.isPlaying = true;
    this.startTime = this.audioCtx.currentTime;
    console.log(`Playback started at ${this.startTime.toFixed(3)} seconds`, "isPlaying:", this.isPlaying);
    this.scheduleSequences();
}

scheduleSequences() {
    console.debug("Scheduling sequences...");
    const log = Object.keys(this.processedData.projectSequences).map((id, i) => 
        this.scheduleSequence(id, this.calculateSequenceStartTime(i))
    );
    console.log('Scheduled Sequences:', log);
}

calculateSequenceStartTime(i) {
    const { projectBPM, globalPlaybackSpeed } = this.processedData;
    return this.startTime + (i * this.getStepsPerSequence() * (60 / projectBPM / 4)) / globalPlaybackSpeed;
}

scheduleSequence(id, startTime) {
    const sequence = this.processedData.projectSequences[id];
    if (!sequence) return console.error(`No data for ${id}.`);

    const { projectBPM, globalPlaybackSpeed } = this.processedData;
    const stepDuration = 60 / projectBPM / 4;
    const log = { id, startTime: startTime.toFixed(3) };
    console.debug(`Scheduled ${id} at ${log.startTime}s`);

    Object.entries(sequence).forEach(([channel, data]) => {
        const buf = this.audioBuffers.find(b => b.channel === channel);
        if (!buf) return console.warn(`No buffer for ${channel}.`);

        data.steps.forEach(({ index, reverse }) => {
            const when = startTime + ((index - 1) * stepDuration) / globalPlaybackSpeed;
            const source = this.audioCtx.createBufferSource();
            source.buffer = reverse && this.reversedAudioBuffers[channel] ? this.reversedAudioBuffers[channel] : buf.buffer;
            source.playbackRate.value = buf.playbackSpeed * globalPlaybackSpeed;
            source.connect(buf.gainNode);
            source.start(when);
            this.currentSourceNodes.push(source);
        });
    });

    const delay = Math.max((startTime - this.audioCtx.currentTime) * 1000, 0);
    if (delay < Number.MAX_SAFE_INTEGER) {
        const tid = setTimeout(() => {
            if (this.isPlaying) console.log(`Now playing ${id}`);
            this.pendingTimeouts = this.pendingTimeouts.filter(t => t !== tid);
        }, delay);
        this.pendingTimeouts.push(tid);
    } else {
        console.warn(`Delay for ${id} too long. Skipping log.`);
    }

    return log;
}

getStepsPerSequence() { 
    return 64; 
}

stop() {
    if (!this.isPlaying) return;
    this.currentSourceNodes.forEach(s => s.stop());
    this.currentSourceNodes = [];
    this.isPlaying = false;
    console.log("Stopped song.", "isPlaying:", this.isPlaying);
    this.pendingTimeouts.forEach(clearTimeout);
    this.pendingTimeouts = [];
}

async extractAudioFromVideo(response, url, channel) {
    try {
        console.log(`Starting audio extraction for ${channel} from ${url}`);
        const videoBlob = await response.blob();
        const videoURL = URL.createObjectURL(videoBlob);
        const video = Object.assign(document.createElement('video'), {
            src: videoURL, crossOrigin: "anonymous", muted: true, style: 'display:none'
        });
        document.body.appendChild(video);

        await new Promise((res, rej) => {
            video.onloadedmetadata = res;
            video.onerror = () => rej(new Error(`Error loading metadata for ${channel}.`));
        });

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const buffer = { left: [], right: [] };
        const scriptNode = audioCtx.createScriptProcessor(4096, 2, 2);

        scriptNode.onaudioprocess = e => {
            buffer.left.push(e.inputBuffer.getChannelData(0).slice());
            buffer.right.push(e.inputBuffer.getChannelData(1).slice());
        };

        audioCtx.createMediaElementSource(video).connect(scriptNode).connect(audioCtx.destination);
        await video.play().catch(err => { throw new Error(`Error playing video: ${err.message}`); });
        console.log(`Starting audio capture for ${channel}...`);

        return await new Promise((res, rej) => {
            video.onended = () => {
                scriptNode.disconnect(); audioCtx.close();
                const offlineCtx = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(2, buffer.left.length, audioCtx.sampleRate);
                const rendered = offlineCtx.createBuffer(2, buffer.left.length, audioCtx.sampleRate);
                [buffer.left, buffer.right].forEach((ch, i) => rendered.copyToChannel(this.concatenateFloat32Arrays(ch), i));
                res(rendered);
                URL.revokeObjectURL(videoURL); document.body.removeChild(video);
            };
            video.onerror = e => rej(new Error(`Playback error for ${channel}.`));
        });
    } catch (error) {
        console.error(`Error extracting audio for ${channel}:`, error);
        throw new Error(`Failed to extract audio for ${channel}.`);
    }
}

concatenateFloat32Arrays(arrays) {
    return arrays.reduce((res, a) => {
        const len = res.length + a.length;
        const result = new Float32Array(len);
        result.set(res); result.set(a, res.length);
        return result;
    }, new Float32Array());
}
}
// Initialize the AudioPlayer instance
new AudioPlayer();

});
</script>

</body>
</html>