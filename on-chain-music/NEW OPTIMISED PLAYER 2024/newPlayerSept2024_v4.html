<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Audionals Ordinal Player</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/1.0.11/pako.min.js" defer></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0; padding: 0;
            min-height: 100vh; display: flex;
            justify-content: center; align-items: center; flex-direction: column;
        }
        h1 { color: #333; margin-bottom: 10px; }
        #buttonContainer { display: flex; gap: 10px; margin-bottom: 20px; }
        button { padding: 10px 20px; cursor: pointer; }
        #loadingIndicator, #errorMessage, #songTitle { margin-top: 10px; }
        #artworkCanvas {
            width: 30vh; height: 30vh; display: flex; justify-content: center; align-items: center;
            border: 2px solid #333; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); margin-top: 20px; background-color: #f9f9f9;
        }
        img, video, iframe { max-width: 100%; max-height: 100%; object-fit: contain; }
        .unsupported { color: red; font-size: 14px; }
    </style>
</head>
<body>
    <h1>Audional Player</h1>
    <div id="buttonContainer">
        <button id="loadButton">Load</button>
        <button id="playButton" disabled>Play</button>
        <button id="stopButton" disabled>Stop</button>
        <button id="skipBackButton" disabled>Skip <</button>
        <button id="skipForwardButton" disabled>Skip ></button>
    </div>
    <div id="loadingIndicator">Loading...</div>
    <div id="errorMessage"></div>
    <div id="songTitle"></div>
    <div id="artworkCanvas">
        <img id="placeholderImage" src="https://ordinals.com/content/01c48d3cceb02215bc3d44f9a2dc7fba63ea63719a2ef1c35d3f0c4db93ab8d5i0" alt="Placeholder Artwork" />
    </div>
    <script>
    let currentSongIndex = 0;  // Initial song index


    const SONGS = [
  {
    songUrl: "https://ordinals.com/content/6d288c0c82653001bb32497889dd1486e8afec9b0671a95fa9e10f99c20737bbi0",
    artworkUrl: "https://ordinals.com/content/dad995f3f46254e73b0470e7ac7e25a874db400324d22c1e2abd8cbf2bebd00ai0",
    name: "Kora algo",
  },
  {
    songUrl: "https://ordinals.com/content/633100d631767ddb9a309f5a2a66f5a66d5abd839f3b1c55642690d484189971i0",
    artworkUrl: "https://ordinals.com/content/2df6f9e192bb34059aabada179857cdcce7891be92fa20a49a66850de8f75a00i0",
    name: "ON DAY ONE",
  },
  {
    songUrl: "https://ordinals.com/content/5527d0cc95ce5ce6eedf4e275234da8b1fe087512d0db618b6de1aaad437c96bi0",
    artworkUrl: "https://ordinals.com/content/cf997386e346140d3d5dbaedbe015c63d81df962a8cc87fc0b571b429d4778b5i5",
    name: "TRUTH",
  },
  {
    songUrl: "https://ordinals.com/content/07ff7bdc47e5272a3ff55cc46d2b189d510562a057a2c24112f3d0376950484di0",
    artworkUrl: "https://ordinals.com/content/ec99785b253c01583e6041e981a7a47134553fae57947e9d0c6c8949bd9e3bf1i0",
    name: "CHOPPIN",
  },
  {
    songUrl: "https://ordinals.com/content/119a3ccd1dfd7e987cca139f86d16717d845a22dd6afc59ad492527b95ae9a91i0",
    artworkUrl: "https://ordinals.com/content/26b15064aaab0f2b10555d37193587c4e4d69801f9af339b7b03fb2a839a6f85i0",
    name: "MLK",
  },
  {
    songUrl: "https://ordinals.com/content/db9131cfe8e933e8e639f007dcd2b582a80bfd2be42b0eafa4d2e206332d6785i0",
    artworkUrl: "https://ordinals.com/content/5a5255d440a282e92444f3d061a4c2565c0a1e26f29f4e24d3d4ce83cbd5071bi0",
    name: "MODERN PROGRESS",
  },
  {
    songUrl: "https://ordinals.com/content/fb0d2abcd1fa5bf2622579f0990435b48d41291f71626fc2e36a93e6ea6b3b85i0",
    artworkUrl: "https://ordinals.com/content/a5475f4d624e0517713ededa758dba0304ee0265c1ed8d5aae6615b2139643c8i0",
    name: "HUMANITY",
  },
  {
    songUrl: "https://ordinals.com/content/8aec0a99a5617b9da98a5b63a11a5143f0cac3cfa662d9515c2285de03ef95d4i0",
    artworkUrl: "https://ordinals.com/content/53381703b96cf1575de69a870e0a731f3bae23218ee35fd7b00cd195ba2c7a39i0",
    name: "I LOVE CHEESE",
  },
  {
    songUrl: "https://ordinals.com/content/3359ce42359274ddbd2184d9f75a38b7e59b1d5f24512959e29c377fc8ca604ai0",
    artworkUrl: "https://ordinals.com/content/8a234e2de569147ed58a86dc59fb4a37e577b702ce49fdf119fbdbe274f30e70i0",
    name: "FRESH VIBES",
  },
  {
    songUrl: "https://ordinals.com/content/b22f1c85371b58a9cdac19b2baa50b1f9025a28d44cdfaad539d0527aa7d894ei0",
    artworkUrl: "https://ordinals.com/content/3a95675d62bd78af488ef60e56f904d0af73e9e54096fba160488381a3a494b2i0",
    name: "ON-CHAIN IN THE MEMBRANE",
  },
  {
    songUrl: "https://ordinals.com/content/9dfa1812b211a7ac8b2f9e77119828ec8fbf2e9016b3d37a8efd70052eb4aa3ci0",
    artworkUrl: "https://ordinals.com/content/918b25dadc46459e6632532980968e2b79af04198c56f3f4715f79c20b12e886i0",
    name: "Based New",
  },
  {
    songUrl: "https://ordinals.com/content/4653bcc45671abdbc024b03ebbaaadb30e0cad83b80898894ab22426bbccdaaei0",
    artworkUrl: "https://ordinals.com/content/fed62e8fa6c6005c07d5ee1d10811662a71c6a99b59bc79afd7e065aec134bbfi0",
    name: "Freedom Remix",
  },
];

// Generate full URL from song ID
const getSongUrl = (id) => id.startsWith(BASE_URL) ? id : `${BASE_URL}${id}`;

        
// Preload all songs and extract project names
const preloadAllSongs = async () => {
    const projectNames = await Promise.all(SONGS.map(async ({ songUrl }, i) => {
        try {
            const res = await fetch(songUrl);
            if (!res.ok) throw new Error(`Failed to fetch song: ${res.statusText}`);

            const data = JSON.parse(new TextDecoder().decode(pako.inflate(new Uint8Array(await res.arrayBuffer()))));
            return data["0"] && data["0"] !== '0' ? data["0"] : 'NoName';
        } catch (error) {
            console.error(`Error loading song ${i}:`, error);
            return 'NoName';
        }
    }));
    console.log("Project Names:", projectNames);
    return projectNames;
};

document.addEventListener('DOMContentLoaded', () => preloadAllSongs());


        document.addEventListener('DOMContentLoaded', () => {
            const keyMap = {
                            "0": "projectName", "1": "artistName", "2": "projectBPM", "3": "currentSequence",
                            "4": "channelURLs", "5": "channelVolume", "6": "channelPlaybackSpeed", "7": "trimSettings",
                            "8": "projectChannelNames", "9": "startSliderValue", "10": "endSliderValue", "11": "totalSampleDuration",
                            "12": "start", "13": "end", "14": "projectSequences", "15": "steps"
                        };
                        const reverseKeyMap = Object.fromEntries(Object.entries(keyMap).map(([k, v]) => [v, k]));

                        const decompressSteps = (steps) =>
                                steps.map(step => {
                                    if (typeof step === "number") return { index: step, reverse: false };
                                    if (typeof step === "string" && step.endsWith("r")) return { index: parseInt(step.slice(0, -1), 10), reverse: true };
                                    if (typeof step === "object" && step.r) return { index: step.r[0], reverse: Boolean(step.r[1]) };
                                    console.warn("Unknown step format:", step);
                                    return null;
                                }).filter(Boolean);

                                const letterToNumber = (() => {
                                    const map = Object.fromEntries([...Array(16)].map((_, i) => [String.fromCharCode(97 + i), i]));
                                    return (letter) => map[letter.toLowerCase()] ?? null;
                                })();

                                const deserialize = (data) =>
                                    Object.fromEntries(Object.entries(data).map(([key, value]) => {
                                        const mappedKey = keyMap[key] || key;
                                        if (mappedKey === "projectSequences") {
                                            return [mappedKey, Object.fromEntries(Object.entries(value).map(([seqKey, seqValue]) => {
                                                const sequenceId = `Sequence${seqKey.replace(/^s/, "")}`;
                                                const channels = Object.fromEntries(Object.entries(seqValue).map(([chanKey, chanData]) => {
                                                    let channelNumber = parseInt(chanKey.replace(/^ch/, ""), 10);
                                                    channelNumber = isNaN(channelNumber) ? letterToNumber(chanKey) : channelNumber;
                                                    return channelNumber !== null ? [`Channel ${channelNumber}`, { steps: decompressSteps(chanData[reverseKeyMap.steps] || []) }] : [];
                                                }).filter(Boolean));
                                                return [sequenceId, channels];
                                            }))];
                                        }
                                        return [mappedKey, value];
                                    }));



class AudioPlayer {
    constructor() {
        this.initializeProperties();
        this.bindUIElements();
        this.initEventListeners();
    }

    initializeProperties() {
        this.projectNames = [];
        this.songLoadCounter = 0;
        this.totalSongs = SONGS.length;
        this.audioBuffers = [];
        this.reversedAudioBuffers = {};
        this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        this.isPlaying = false;
        this.currentSourceNodes = [];
        this.processedData = {};
        this.currentSequence = 0;
        this.startTime = 0;
        this.pendingTimeouts = [];
    }

    bindUIElements() {
        ['loadButton', 'playButton', 'stopButton', 'skipForwardButton', 'skipBackButton', 'loadingIndicator', 'errorMessage', 'songTitle', 'artworkCanvas']
            .forEach(id => this[id] = document.getElementById(id));
    }

    initEventListeners() {
        this.loadButton.addEventListener('click', () => this.loadButtonHandler());
        this.playButton.addEventListener('click', () => this.play());
        this.stopButton.addEventListener('click', () => this.stop());
        this.skipForwardButton.addEventListener('click', () => this.skipSong('forward'));
        this.skipBackButton.addEventListener('click', () => this.skipSong('back'));
    }

    showSongTitle(title) {
        this.songTitle.textContent = title;
    }
    async loadSong(url, autoPlay = false) {
        this.reset();
        try {
            this.showLoading(true);
            await this.loadGzipSongFile(url);
            this.toggleButtons(false);
            
            // Get artwork URL for the current song
            const song = SONGS[currentSongIndex];
            if (song && song.artworkUrl) {
                await this.displayArtwork(song.artworkUrl); // Use the correct artwork URL
            } else {
                console.warn(`No artwork URL found for song at index ${currentSongIndex}`);
            }

            if (autoPlay) this.play();
        } catch (e) {
            console.error("Error loading file:", e);
            this.displayError("Failed to load file.");
        } finally {
            this.showLoading(false);
        }
    }

async displayArtwork(url) {
    this.artworkCanvas.innerHTML = ''; // Clear the artwork canvas
    try {
        const res = await fetch(url, { method: 'HEAD' });
        if (!res.ok) throw new Error(`Failed to fetch artwork: ${res.status}`);
        const contentType = res.headers.get('Content-Type');
        const mediaElement = this.createMediaElement(contentType, url, currentSongIndex); // Pass the currentSongIndex for alt text
        this.artworkCanvas.appendChild(mediaElement);
    } catch (error) {
        console.error(`Error displaying artwork:`, error);
        this.artworkCanvas.appendChild(this.createErrorElement('Failed to load artwork.'));
    }
}

createMediaElement(contentType, url, songIndex) {
    const elements = {
        image: () => {
            const img = Object.assign(document.createElement('img'), {
                src: url,
                alt: `Artwork for song ${songIndex + 1}`, // Use the current song index for alt text
                onload: () => this.fitMediaElement(this.artworkCanvas, img) // Fit the image within the canvas
            });
            return img;
        },
        video: () => Object.assign(document.createElement('video'), { src: url, controls: true }),
        audio: () => Object.assign(document.createElement('audio'), { src: url, controls: true }),
        html: () => Object.assign(document.createElement('iframe'), { src: url, width: '100%', height: '100%', frameBorder: 0 })
    };

    const type = contentType.split('/')[0]; // Get the type (image, video, audio, etc.)
    return elements[type] ? elements[type]() : this.createErrorElement('Unsupported artwork format.');
}

    fitMediaElement(container, element) {
        if (!element || !element.naturalWidth || !element.naturalHeight) {
            console.error('Element is undefined or does not have natural dimensions.');
            return;
        }

        const { clientWidth: w, clientHeight: h } = container;
        const imgAspect = element.naturalWidth / element.naturalHeight;
        const canvasAspect = w / h;

        element.style.width = imgAspect > canvasAspect ? '100%' : 'auto';
        element.style.height = imgAspect > canvasAspect ? 'auto' : '100%';
    }


    createErrorElement(message) {
        return Object.assign(document.createElement('div'), { className: 'unsupported', textContent: message });
    }


   
    toggleButtons(disabled) {
        [this.playButton, this.stopButton, this.skipForwardButton, this.skipBackButton].forEach(btn => btn.disabled = disabled);
    }

    async loadButtonHandler() {
        await this.loadSong(SONGS[currentSongIndex].songUrl);
    }

    async skipSong(direction) {
        currentSongIndex = (direction === 'forward') 
            ? (currentSongIndex + 1) % SONGS.length 
            : (currentSongIndex - 1 + SONGS.length) % SONGS.length;
        await this.loadSong(SONGS[currentSongIndex].songUrl, this.isPlaying);
    }

    reset() {
        this.stop();
        this.audioBuffers = [];
        this.reversedAudioBuffers = {};
        this.currentSourceNodes.forEach(s => s.stop?.());
        this.currentSourceNodes = [];
        this.pendingTimeouts.forEach(clearTimeout);
        this.pendingTimeouts = [];
        this.processedData = {};
        this.currentSequence = this.startTime = 0;
        this.toggleButtons(true);
        this.artworkCanvas.innerHTML = '';
    }

    showLoading(isLoading) {
        this.loadingIndicator.style.display = isLoading ? 'block' : 'none';
    }

    displayError(message) {
        this.errorMessage.textContent = message;
    }



    async loadGzipSongFile(url) {
        try {
            const res = await fetch(url);
            if (!res.ok) throw new Error(`Network response not ok: ${res.statusText}`);

            const data = deserialize(JSON.parse(new TextDecoder().decode(pako.inflate(new Uint8Array(await res.arrayBuffer())))));
            const projectName = data.projectName || 'NoName';
            this.showSongTitle(projectName);
            this.projectNames.push(projectName);

            const metadata = {
                projectName,
                artistName: data.artistName,
                projectBPM: data.projectBPM,
                currentSequence: data.currentSequence,
                channelURLs: this.arrayToObject(data.channelURLs),
                channelVolume: this.arrayToObject(data.channelVolume, 0, true),
                channelPlaybackSpeed: this.arrayToObject(data.channelPlaybackSpeed, 0, true),
                trimSettings: this.mapTrimSettings(data.trimSettings),
                projectChannelNames: data.projectChannelNames,
                projectSequences: data.projectSequences,
                globalPlaybackSpeed: data.globalPlaybackSpeed || 1,
            };

            this.processedData = {
                ...metadata,
                VOLUME_CONTROLS: metadata.channelVolume,
                SPEED_CONTROLS: metadata.channelPlaybackSpeed,
                songDataUrls: Object.values(metadata.channelURLs),
            };

            console.log(`Sequences loaded: ${Object.keys(this.processedData.projectSequences).length}`);

            if (this.processedData.songDataUrls.length === 16) {
                await this.fetchAndProcessAudioData(this.processedData.songDataUrls.map(u => `https://ordinals.com${u}`));
            } else {
                throw new Error("Invalid channel URLs or channel count.");
            }

            if (++this.songLoadCounter === this.totalSongs) this.logProjectNames();
        } catch (error) {
            console.error(`Error loading file:`, error);
        }
    }

    arrayToObject(arr, start = 0, parse = false) {
    return arr.reduce((obj, val, idx) => {
        obj[`Channel ${start + idx}`] = parse ? parseFloat(val) || 1 : val;
        return obj;
    }, {});
}

mapTrimSettings(arr) {
    return arr.reduce((obj, item, idx) => {
        obj[`Channel ${idx}`] = typeof item === 'object' && item
            ? { start: item[9] || 0, end: item[10] || 100 }
            : { start: 0, end: typeof item === 'number' ? item : 100 };
        if (typeof item !== 'object' && typeof item !== 'number') console.warn(`Invalid trim for Channel ${idx}.`);
        return obj;
    }, {});
}

async fetchAndProcessAudioData(urls) {
    const results = await Promise.allSettled(urls.map(this.processAudioUrl.bind(this)));
    results.forEach((res, i) => res.status === 'rejected' && console.error(`Failed Channel ${i} (${urls[i]}):`, res.reason));
    this.createReversedBuffers();
}

async processAudioUrl(url, index) {
    const channelName = `Channel ${index}`;
    try {
        const res = await fetch(url);
        if (!res.ok) throw new Error(`Fetch failed: ${url}, Status: ${res.status}`);

        const audioBuffer = await this.handleResponseByType(res, res.headers.get("Content-Type"), channelName);
        if (audioBuffer) {
            this.logAudioBufferDetails(audioBuffer, channelName);
            this.storeAudioBuffer(audioBuffer, channelName);
        }
    } catch (error) {
        console.error(`Error processing ${channelName}:`, error);
    }
}

async handleResponseByType(response, contentType, channelName) {
    if (/audio|video/.test(contentType)) {
        return this.fetchAndDecodeAudio(response, channelName);
    }
    if (/json/.test(contentType)) {
        return this.handleResponse(response, channelName, 'JSON'); // Unified response handling
    }
    if (/html/.test(contentType)) {
        return this.handleResponse(response, channelName, 'HTML'); // Unified response handling
    }
    throw new Error(`Unsupported content type for ${channelName}: ${contentType}`);
}

async handleResponse(response, channelName, type) {
    return this.handleAudioDataFromResponse(response, channelName, type);
}

logAudioBufferDetails(audioBuffer, channelName) {
    console.log(`AudioBuffer for ${channelName}:`, {
        channels: audioBuffer.numberOfChannels,
        length: audioBuffer.length,
        sampleRate: audioBuffer.sampleRate,
        duration: audioBuffer.duration,
    });
    [...Array(audioBuffer.numberOfChannels).keys()].forEach(c =>
        console.log(`Channel ${c} data:`, audioBuffer.getChannelData(c).slice(0, 10))
    );
}

storeAudioBuffer(audioBuffer, channelName) {
    const { VOLUME_CONTROLS, SPEED_CONTROLS, trimSettings } = this.processedData;
    const volume = this.parseVolumeLevel(VOLUME_CONTROLS[channelName]);
    const speed = SPEED_CONTROLS[channelName] || 1;
    const trim = trimSettings[channelName] || { start: 0, end: 100 };
    const trimmedBuffer = this.applyTrim(audioBuffer, trim.start, trim.end);

    const gainNode = this.audioCtx.createGain();
    gainNode.gain.value = volume;
    gainNode.connect(this.audioCtx.destination);

    this.audioBuffers.push({ buffer: trimmedBuffer, gainNode, channel: channelName, playbackSpeed: speed });
}

async fetchAndDecodeAudio(response, channelName) {
    try {
        const arrayBuffer = await response.arrayBuffer();
        const audioBuffer = await this.audioCtx.decodeAudioData(arrayBuffer);
        console.log(`Decoded ${channelName}.`);
        return audioBuffer;
    } catch (error) {
        console.error(`decodeAudioData failed for ${channelName}:`, error);
        throw new Error(`Failed to decode audio for ${channelName}.`);
    }
}


async handleAudioDataFromResponse(response, channelName, type) {
    try {
        const data = type === 'JSON' ? await response.json() : await response.text();
        const base64Audio = type === 'JSON' ? data.audioData : this.extractBase64FromHTML(data);
        
        if (base64Audio) {
            const arrayBuffer = this.base64ToArrayBuffer(base64Audio.split(",")[1]);
            try {
                const audioBuffer = await this.audioCtx.decodeAudioData(arrayBuffer);
                return audioBuffer;
            } catch (error) {
                console.error(`decodeAudioData failed for ${type} audio data in ${channelName}:`, error);
                throw new Error(`Failed to decode ${type} audio data for ${channelName}.`);
            }
        }
        throw new Error(`Invalid ${type} structure for audio data in ${channelName}.`);
    } catch (error) {
        console.error(`Error handling ${type} response for ${channelName}:`, error);
        throw error;
    }
}

    base64ToArrayBuffer(base64) {
        try {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        } catch (error) {
            console.error("[base64ToArrayBuffer] Conversion error:", error);
            return null;
        }
    }

    extractBase64FromHTML(htmlContent) {
        try {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlContent, "text/html");
            const audioSource = doc.querySelector("audio[data-audionalSampleName] source")?.getAttribute("src");
            if (/^data:audio\/(wav|mp3|mp4);base64,/.test(audioSource?.toLowerCase()) || /audio\//.test(audioSource?.toLowerCase())) {
                return audioSource;
            }
            console.error("[extractBase64FromHTML] Invalid audio source format.");
        } catch (error) {
            console.error("[extractBase64FromHTML] Parsing error:", error);
        }
        return null;
    }

    parseVolumeLevel(volume) {
    return Math.max(0, Math.min(parseFloat(volume) || 1, 1));
}

applyTrim(buffer, startPercent, endPercent) {
    const totalSamples = buffer.length;
    const [startSample, endSample] = [startPercent, endPercent].map(p => Math.floor(totalSamples * (p / 100)));

    if (startSample >= endSample || startSample < 0 || endSample > totalSamples) {
        console.warn(`Invalid trim settings: Start = ${startPercent}%, End = ${endPercent}%. Using full buffer.`);
        return buffer;
    }

    const trimmedBuffer = this.audioCtx.createBuffer(buffer.numberOfChannels, endSample - startSample, buffer.sampleRate);
    buffer.numberOfChannels && Array.from({ length: buffer.numberOfChannels }).forEach((_, channel) => {
        trimmedBuffer.copyToChannel(buffer.getChannelData(channel).subarray(startSample, endSample), channel);
    });

    return trimmedBuffer;
}


createReversedBuffers() {
    const channelsWithReverse = new Set();
    console.debug("Starting createReversedBuffers");

    Object.values(this.processedData.projectSequences).forEach((sequence, seqIndex) => {
        console.debug(`Processing sequence ${seqIndex + 1}/${Object.keys(this.processedData.projectSequences).length}`);
        Object.entries(sequence).forEach(([channelName, channelData]) => {
            channelData.steps.forEach(({ reverse }, stepIndex) => {
                if (reverse) {
                    channelsWithReverse.add(channelName);
                    console.debug(`  Step ${stepIndex + 1}: Reverse flag set for channel '${channelName}'`);
                }
            });
        });
    });

    console.debug("Channels requiring reversal:", Array.from(channelsWithReverse));

    this.audioBuffers.forEach(({ buffer, channel }) => {
        if (channelsWithReverse.has(channel)) {
            if (!this.reversedAudioBuffers[channel]) {
                console.debug(`Reversing buffer for channel: ${channel}`);
                this.reversedAudioBuffers[channel] = this.reverseBuffer(buffer);
            } else {
                console.debug(`Buffer for channel ${channel} already reversed.`);
            }
        }
    });

    console.debug("Completed createReversedBuffers");
}


    reverseBuffer(buffer) {
        console.debug("Starting reverseBuffer");
        const reversedBuffer = this.audioCtx.createBuffer(buffer.numberOfChannels, buffer.length, buffer.sampleRate);

        for (let channel = 0; channel < buffer.numberOfChannels; channel++) {
            const channelData = buffer.getChannelData(channel);
            const reversedData = reversedBuffer.getChannelData(channel);
            console.debug(`  Reversing data for channel ${channel + 1}/${buffer.numberOfChannels}`);
            
            for (let i = 0, len = buffer.length; i < len; i++) {
                reversedData[i] = channelData[len - i - 1];
            }
        }

        console.debug("Completed reverseBuffer");
        return reversedBuffer;
    }
// Playback methods
play() {
    if (this.isPlaying) return;
    this.isPlaying = true;
    this.startTime = this.audioCtx.currentTime;
    console.log(`Playback started at ${this.startTime.toFixed(3)} seconds`, "isPlaying:", this.isPlaying);
    this.scheduleSequences();
}

scheduleSequences() {
    console.debug("Scheduling sequences...");
    const log = Object.keys(this.processedData.projectSequences).map((id, i) => 
        this.scheduleSequence(id, this.calculateSequenceStartTime(i))
    );
    console.log('Scheduled Sequences:', log);
}

calculateSequenceStartTime(i) {
    const { projectBPM, globalPlaybackSpeed } = this.processedData;
    return this.startTime + (i * this.getStepsPerSequence() * (60 / projectBPM / 4)) / globalPlaybackSpeed;
}

scheduleSequence(id, startTime) {
    const sequence = this.processedData.projectSequences[id];
    if (!sequence) return console.error(`No data for ${id}.`);

    const { projectBPM, globalPlaybackSpeed } = this.processedData;
    const stepDuration = 60 / projectBPM / 4;
    const log = { id, startTime: startTime.toFixed(3) };
    console.debug(`Scheduled ${id} at ${log.startTime}s`);

    Object.entries(sequence).forEach(([channel, data]) => {
        const buf = this.audioBuffers.find(b => b.channel === channel);
        if (!buf) return console.warn(`No buffer for ${channel}.`);

        data.steps.forEach(({ index, reverse }) => {
            const when = startTime + ((index - 1) * stepDuration) / globalPlaybackSpeed;
            const source = this.audioCtx.createBufferSource();
            source.buffer = reverse && this.reversedAudioBuffers[channel] ? this.reversedAudioBuffers[channel] : buf.buffer;
            source.playbackRate.value = buf.playbackSpeed * globalPlaybackSpeed;
            source.connect(buf.gainNode);
            source.start(when);
            this.currentSourceNodes.push(source);
        });
    });

    const delay = Math.max((startTime - this.audioCtx.currentTime) * 1000, 0);
    if (delay < Number.MAX_SAFE_INTEGER) {
        const tid = setTimeout(() => {
            if (this.isPlaying) console.log(`Now playing ${id}`);
            this.pendingTimeouts = this.pendingTimeouts.filter(t => t !== tid);
        }, delay);
        this.pendingTimeouts.push(tid);
    } else {
        console.warn(`Delay for ${id} too long. Skipping log.`);
    }

    return log;
}

getStepsPerSequence() { 
    return 64; 
}

stop() {
    if (!this.isPlaying) return;
    this.currentSourceNodes.forEach(s => s.stop());
    this.currentSourceNodes = [];
    this.isPlaying = false;
    console.log("Stopped song.", "isPlaying:", this.isPlaying);
    this.pendingTimeouts.forEach(clearTimeout);
    this.pendingTimeouts = [];
}

async extractAudioFromVideo(response, url, channel) {
    try {
        console.log(`Starting audio extraction for ${channel} from ${url}`);
        const videoBlob = await response.blob();
        const videoURL = URL.createObjectURL(videoBlob);
        const video = Object.assign(document.createElement('video'), {
            src: videoURL, crossOrigin: "anonymous", muted: true, style: 'display:none'
        });
        document.body.appendChild(video);

        await new Promise((res, rej) => {
            video.onloadedmetadata = res;
            video.onerror = () => rej(new Error(`Error loading metadata for ${channel}.`));
        });

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const buffer = { left: [], right: [] };
        const scriptNode = audioCtx.createScriptProcessor(4096, 2, 2);

        scriptNode.onaudioprocess = e => {
            buffer.left.push(e.inputBuffer.getChannelData(0).slice());
            buffer.right.push(e.inputBuffer.getChannelData(1).slice());
        };

        audioCtx.createMediaElementSource(video).connect(scriptNode).connect(audioCtx.destination);
        await video.play().catch(err => { throw new Error(`Error playing video: ${err.message}`); });
        console.log(`Starting audio capture for ${channel}...`);

        return await new Promise((res, rej) => {
            video.onended = () => {
                scriptNode.disconnect(); audioCtx.close();
                const offlineCtx = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(2, buffer.left.length, audioCtx.sampleRate);
                const rendered = offlineCtx.createBuffer(2, buffer.left.length, audioCtx.sampleRate);
                [buffer.left, buffer.right].forEach((ch, i) => rendered.copyToChannel(this.concatenateFloat32Arrays(ch), i));
                res(rendered);
                URL.revokeObjectURL(videoURL); document.body.removeChild(video);
            };
            video.onerror = e => rej(new Error(`Playback error for ${channel}.`));
        });
    } catch (error) {
        console.error(`Error extracting audio for ${channel}:`, error);
        throw new Error(`Failed to extract audio for ${channel}.`);
    }
}

concatenateFloat32Arrays(arrays) {
    return arrays.reduce((res, a) => {
        const len = res.length + a.length;
        const result = new Float32Array(len);
        result.set(res); result.set(a, res.length);
        return result;
    }, new Float32Array());
}
}
// Initialize the AudioPlayer instance
new AudioPlayer();

});
</script>

</body>
</html>